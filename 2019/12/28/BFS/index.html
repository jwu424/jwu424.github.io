<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>BFS | Pinecone</title><meta name="description" content="BFS"><meta name="keywords" content=""><meta name="author" content="Pinecone"><meta name="copyright" content="Pinecone"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="https://www.pinew.top/2019/12/28/BFS/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="BFS"><meta name="twitter:description" content="BFS"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jwu424/Blog_source@master/img/U2En1ED8DLs.jpg"><meta property="og:type" content="article"><meta property="og:title" content="BFS"><meta property="og:url" content="https://www.pinew.top/2019/12/28/BFS/"><meta property="og:site_name" content="Pinecone"><meta property="og:description" content="BFS"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/jwu424/Blog_source@master/img/U2En1ED8DLs.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="prev" title="DFS" href="https://www.pinew.top/2020/01/06/DFS/"><link rel="next" title="TwoPointers" href="https://www.pinew.top/2019/12/26/TwoPointers/"><meta name="google-site-verification" content="google078980f9392d4c28.html"><meta name="baidu-site-verification" content="baidu_verify_4E5F1x6oOR.html"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight_copy: 'true',
  highlight_lang: 'true',
  highlight_shrink: 'true',
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    title: 'Bookmark',
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  copyright: undefined,
  copy_copyright_js: false
  
}</script></head><body><canvas class="fireworks"></canvas><div id="header"> <div id="page-header"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">Pinecone</a></span><i class="fa fa-bars fa-fw toggle-menu pull-right close" aria-hidden="true"></i><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw far fa-image"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/books/"><i class="fa-fw fa fa-book"></i><span> Books</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movies</span></a></li><li><a class="site-page" href="/games/"><i class="fa-fw fa fa-gamepad"></i><span> Games</span></a></li></ul></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lozad avatar_img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">17</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">4</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">Categories</div><div class="length_num">4</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw far fa-image"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/books/"><i class="fa-fw fa fa-book"></i><span> Books</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movies</span></a></li><li><a class="site-page" href="/games/"><i class="fa-fw fa fa-gamepad"></i><span> Games</span></a></li></ul></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">Catalog</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Question-1-Symmetric-Tree"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">Question 1: Symmetric Tree</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Question-2-Binary-Tree-Zigzag-Level-Order-Traversal"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">Question 2: Binary Tree Zigzag Level Order Traversal</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Question-3-Word-Ladder"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">Question 3: Word Ladder</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Question-3-Surrounded-Regions"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">Question 3: Surrounded Regions</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Question-4-Binary-Tree-Right-Side-View"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">Question 4: Binary Tree Right Side View</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Question-5-Binary-Tree-boundary-nodes"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">Question 5: Binary Tree boundary nodes</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Question-6-Number-of-Islands"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text">Question 6: Number of Islands</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Question-7-Perfect-Squares"><span class="toc_mobile_items-number">8.</span> <span class="toc_mobile_items-text">Question 7: Perfect Squares</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Question-8-Minimum-Height-Trees"><span class="toc_mobile_items-number">9.</span> <span class="toc_mobile_items-text">Question 8: Minimum Height Trees</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Question-9-Trapping-Rain-Water-II"><span class="toc_mobile_items-number">10.</span> <span class="toc_mobile_items-text">Question 9: Trapping Rain Water II</span></a></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Question-1-Symmetric-Tree"><span class="toc-number">1.</span> <span class="toc-text">Question 1: Symmetric Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Question-2-Binary-Tree-Zigzag-Level-Order-Traversal"><span class="toc-number">2.</span> <span class="toc-text">Question 2: Binary Tree Zigzag Level Order Traversal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Question-3-Word-Ladder"><span class="toc-number">3.</span> <span class="toc-text">Question 3: Word Ladder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Question-3-Surrounded-Regions"><span class="toc-number">4.</span> <span class="toc-text">Question 3: Surrounded Regions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Question-4-Binary-Tree-Right-Side-View"><span class="toc-number">5.</span> <span class="toc-text">Question 4: Binary Tree Right Side View</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Question-5-Binary-Tree-boundary-nodes"><span class="toc-number">6.</span> <span class="toc-text">Question 5: Binary Tree boundary nodes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Question-6-Number-of-Islands"><span class="toc-number">7.</span> <span class="toc-text">Question 6: Number of Islands</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Question-7-Perfect-Squares"><span class="toc-number">8.</span> <span class="toc-text">Question 7: Perfect Squares</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Question-8-Minimum-Height-Trees"><span class="toc-number">9.</span> <span class="toc-text">Question 8: Minimum Height Trees</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Question-9-Trapping-Rain-Water-II"><span class="toc-number">10.</span> <span class="toc-text">Question 9: Trapping Rain Water II</span></a></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/jwu424/Blog_source@master/img/U2En1ED8DLs.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">BFS</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> Created 2019-12-28<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> Updated 2019-12-29</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Leetcode/">Leetcode</a></span><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">2.8k</span><span class="post-meta__separator">|</span><span>Reading time: 17 min</span><span class="post-meta__separator">|</span><span>Post View: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h3 id="Question-1-Symmetric-Tree"><a href="#Question-1-Symmetric-Tree" class="headerlink" title="Question 1: Symmetric Tree"></a>Question 1: Symmetric Tree</h3><p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>
<p>For example, this binary tree <code>[1,2,2,3,4,4,3]</code> is symmetric. </p>
<p>But <code>[1,2,2,null,3,null,3]</code> is not.</p>
<p><strong>Answer:</strong></p>
<p>We can use deque to store and loop each level. One thing we should notice that we need to add None to curlevel if sub-node is None. </p>
<p>BFS+Iterative:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time: O(N)</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        queue = deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            curlevel = []</span><br><span class="line">            levelSize = len(queue)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(levelSize):</span><br><span class="line">                curNode = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> curNode:</span><br><span class="line">                    curlevel.append(curNode.val)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    curlevel.append(<span class="literal">None</span>)</span><br><span class="line">                <span class="keyword">if</span> curNode:</span><br><span class="line">                    queue.append(curNode.left)</span><br><span class="line">                    queue.append(curNode.right)</span><br><span class="line">            <span class="keyword">if</span> curlevel != curlevel[::<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>BFS+Simplify version</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">    	queue = [root]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            curlevel = [i.val <span class="keyword">if</span> i <span class="keyword">else</span> <span class="literal">None</span> <span class="keyword">for</span> i <span class="keyword">in</span> queue]</span><br><span class="line">            <span class="keyword">if</span> curlevel != curlevel[::<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            queue = [child <span class="keyword">for</span> i <span class="keyword">in</span> queue <span class="keyword">if</span> i <span class="keyword">for</span> child <span class="keyword">in</span> (i.left, i.right)]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>BFS+Recursive:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">isSys</span><span class="params">(L, R)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> L <span class="keyword">and</span> R <span class="keyword">and</span> L.val == R.val:</span><br><span class="line">                <span class="keyword">return</span> isSys(L.left, R.right) <span class="keyword">and</span> isSys(L.right, R.left)</span><br><span class="line">            <span class="keyword">return</span> L == R</span><br><span class="line">       	<span class="keyword">return</span> <span class="keyword">not</span> root <span class="keyword">or</span> isSys(root.left, root.right)</span><br></pre></td></tr></table></figure>
<h3 id="Question-2-Binary-Tree-Zigzag-Level-Order-Traversal"><a href="#Question-2-Binary-Tree-Zigzag-Level-Order-Traversal" class="headerlink" title="Question 2: Binary Tree Zigzag Level Order Traversal"></a>Question 2: Binary Tree Zigzag Level Order Traversal</h3><p>Given a binary tree, return the <em>zigzag level order</em> traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).</p>
<p><strong>Answer:</strong></p>
<p>It is a classic BFS question.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time: O(N)</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">zigzagLevelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        res = deque()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        queue = deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        leftToright = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            levelsize = len(queue)</span><br><span class="line">            curlevel = deque()</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(levelsize):</span><br><span class="line">                curnode = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> leftToright:</span><br><span class="line">                    curlevel.append(curnode.val)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    curlevel.appendleft(curnode.val)</span><br><span class="line">                <span class="keyword">if</span> curnode.left:</span><br><span class="line">                    queue.append(curnode.left)</span><br><span class="line">                <span class="keyword">if</span> curnode.right:</span><br><span class="line">                    queue.append(curnode.right)</span><br><span class="line">            leftToright = <span class="keyword">not</span> leftToright</span><br><span class="line">            res.append(list(curlevel))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="Question-3-Word-Ladder"><a href="#Question-3-Word-Ladder" class="headerlink" title="Question 3: Word Ladder"></a>Question 3: Word Ladder</h3><p>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary’s word list, find the length of shortest transformation sequence from <em>beginWord</em> to <em>endWord</em>, such that:</p>
<ol>
<li>Only one letter can be changed at a time.</li>
<li>Each transformed word must exist in the word list. Note that <em>beginWord</em> is <em>not</em> a transformed word.</li>
</ol>
<p><strong>Note:</strong></p>
<ul>
<li>Return 0 if there is no such transformation sequence.</li>
<li>All words have the same length.</li>
<li>All words contain only lowercase alphabetic characters.</li>
<li>You may assume no duplicates in the word list.</li>
<li>You may assume <em>beginWord</em> and <em>endWord</em> are non-empty and are not the same.</li>
</ul>
<p><strong>Answer:</strong></p>
<p>Each time, we change one letter for word, and compare it with words in wordList, if we find, then we append it to queue. Also, we need to record words we have used, in case there is a loop. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time: O(26*L*N). L: length of word. N: total word in wordList</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ladderLength</span><span class="params">(self, beginWord: str, endWord: str, wordList: List[str])</span> -&gt; int:</span></span><br><span class="line">        word_set = set(wordList)</span><br><span class="line">        word_set.add(beginWord)</span><br><span class="line">        <span class="keyword">if</span> endWord <span class="keyword">not</span> <span class="keyword">in</span> word_set:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        q = []</span><br><span class="line">        char_set = <span class="string">"qwertyuiopasdfghjklzxcvbnm"</span></span><br><span class="line">        q.append((beginWord, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        visited = set()</span><br><span class="line">        visited.add(beginWord)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> len(q) &gt; <span class="number">0</span>:</span><br><span class="line">            word, moves = q.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(word)):</span><br><span class="line">                <span class="keyword">for</span> c <span class="keyword">in</span> char_set:</span><br><span class="line">                    new_word = word[:i] + c + word[i + <span class="number">1</span>:]</span><br><span class="line">                    <span class="keyword">if</span> new_word <span class="keyword">not</span> <span class="keyword">in</span> visited <span class="keyword">and</span> new_word <span class="keyword">in</span> word_set:</span><br><span class="line">                        <span class="keyword">if</span> new_word == endWord:</span><br><span class="line">                            <span class="keyword">return</span> moves + <span class="number">1</span></span><br><span class="line">                        q.append((new_word, moves + <span class="number">1</span>))</span><br><span class="line">                        visited.add(new_word)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>Another way is to create a dictionary. For each word in wordList and each position in that word, we use * to replace it and then we find words with same patter. </p>
<p>For example, wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]. For “hot”, we will create a dictionary:  {‘*ot’: [‘hot’, ‘dot’, ‘lot’], ‘h*t’: [‘hot’], ‘ho*‘: [‘hot’], ‘d*t’: [‘dot’], ‘do*‘: [‘dot’, ‘dog’], ‘*og’: [‘dog’, ‘log’, ‘cog’], ‘d*g’: [‘dog’], ‘l*t’: [‘lot’], ‘lo*‘: [‘lot’, ‘log’], ‘l*g’: [‘log’], ‘c*g’: [‘cog’], ‘co*‘: [‘cog’]}</p>
<p>Then, starting from beginWord, we can use same way and try to find whether this pattern exists in the dictionary. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time: O(L*N)</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque, defaultdict</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ladderLength</span><span class="params">(self, beginWord: str, endWord: str, wordList: List[str])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> endWord <span class="keyword">not</span> <span class="keyword">in</span> wordList:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        seen, memo = set(), defaultdict(list)</span><br><span class="line">        n = len(beginWord)</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> wordList:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                x = word[:i] + <span class="string">'*'</span> + word[i+<span class="number">1</span>:]</span><br><span class="line">                memo[x].append(word)</span><br><span class="line">        queue = deque()</span><br><span class="line">        queue.append((beginWord, <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            curr, step = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> curr == endWord:</span><br><span class="line">                <span class="keyword">return</span> step</span><br><span class="line">            seen.add(curr)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                x = curr[:i] + <span class="string">'*'</span> + curr[i+<span class="number">1</span>:]</span><br><span class="line">                <span class="keyword">for</span> y <span class="keyword">in</span> memo[x]:</span><br><span class="line">                    <span class="keyword">if</span> y <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                        queue.append((y, step+<span class="number">1</span>))</span><br><span class="line">                        seen.add(y)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="Question-3-Surrounded-Regions"><a href="#Question-3-Surrounded-Regions" class="headerlink" title="Question 3: Surrounded Regions"></a>Question 3: Surrounded Regions</h3><p>Given a 2D board containing <code>&#39;X&#39;</code> and <code>&#39;O&#39;</code> (<strong>the letter O</strong>), capture all regions surrounded by <code>&#39;X&#39;</code>.</p>
<p>A region is captured by flipping all <code>&#39;O&#39;</code>s into <code>&#39;X&#39;</code>s in that surrounded region.</p>
<p>Input: [[“X”,”X”,”X”,”X”],[“X”,”O”,”O”,”X”],[“X”,”X”,”O”,”X”],[“X”,”O”,”X”,”X”]]</p>
<p>Output: [[“X”,”X”,”X”,”X”],[“X”,”X”,”X”,”X”],[“X”,”X”,”X”,”X”],[“X”,”O”,”X”,”X”]] </p>
<p><strong>Answer:</strong></p>
<p>We can first to find the ‘O’ in the boundary of the matrix and store them in deque. And then we can try to find any ‘O’ that connect with ‘O’ in the deque. We can rename ‘O’ to any name, in order to distinguish with ‘O’ needed to be flipped. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time: O(N^2)</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(self, board: List[List[str]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        queue = deque([])</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> range(len(board)):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> range(len(board[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> (r <span class="keyword">in</span> [<span class="number">0</span>, len(board)<span class="number">-1</span>] <span class="keyword">or</span> c <span class="keyword">in</span> [<span class="number">0</span>, len(board[<span class="number">0</span>])<span class="number">-1</span>]) <span class="keyword">and</span> board[r][c] == <span class="string">'O'</span>:</span><br><span class="line">                    queue.append((r, c))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            r, c = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= r &lt; len(board) <span class="keyword">and</span> <span class="number">0</span> &lt;= c &lt; len(board[<span class="number">0</span>]) <span class="keyword">and</span> board[r][c] == <span class="string">'O'</span>:</span><br><span class="line">                board[r][c]= <span class="string">'D'</span></span><br><span class="line">                queue.append((r<span class="number">-1</span>, c))</span><br><span class="line">                queue.append((r+<span class="number">1</span>, c))</span><br><span class="line">                queue.append((r, c<span class="number">-1</span>))</span><br><span class="line">                queue.append((r, c+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> range(len(board)):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> range(len(board[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> board[r][c] == <span class="string">'O'</span>:</span><br><span class="line">                    board[r][c] = <span class="string">'X'</span></span><br><span class="line">                <span class="keyword">elif</span> board[r][c] == <span class="string">'D'</span>:</span><br><span class="line">                    board[r][c] = <span class="string">'O'</span></span><br></pre></td></tr></table></figure>
<p>Optimize the above.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time: O(N^2)</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(self, board: List[List[str]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> board <span class="keyword">or</span> <span class="keyword">not</span> board[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        R, C = len(board), len(board[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> R &lt;= <span class="number">2</span> <span class="keyword">or</span> C &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        queue = deque([])</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> range(R):</span><br><span class="line">            queue.append((r, <span class="number">0</span>))</span><br><span class="line">            queue.append((r, C - <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> range(C):</span><br><span class="line">            queue.append((<span class="number">0</span>, c))</span><br><span class="line">            queue.append((R - <span class="number">1</span>, c))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            r, c = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= r &lt; R <span class="keyword">and</span> <span class="number">0</span> &lt;= c &lt; C <span class="keyword">and</span> board[r][c] == <span class="string">'O'</span>:</span><br><span class="line">                board[r][c]= <span class="string">'D'</span></span><br><span class="line">                queue.append((r<span class="number">-1</span>, c))</span><br><span class="line">                queue.append((r+<span class="number">1</span>, c))</span><br><span class="line">                queue.append((r, c<span class="number">-1</span>))</span><br><span class="line">                queue.append((r, c+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> range(R):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> range(C):</span><br><span class="line">                <span class="keyword">if</span> board[r][c] == <span class="string">'O'</span>:</span><br><span class="line">                    board[r][c] = <span class="string">'X'</span></span><br><span class="line">                <span class="keyword">elif</span> board[r][c] == <span class="string">'D'</span>:</span><br><span class="line">                    board[r][c] = <span class="string">'O'</span></span><br></pre></td></tr></table></figure>
<h3 id="Question-4-Binary-Tree-Right-Side-View"><a href="#Question-4-Binary-Tree-Right-Side-View" class="headerlink" title="Question 4: Binary Tree Right Side View"></a>Question 4: Binary Tree Right Side View</h3><p>Given a binary tree, imagine yourself standing on the <em>right</em> side of it, return the values of the nodes you can see ordered from top to bottom.</p>
<p><strong>Answer:</strong></p>
<p>Classic question. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rightSideView</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        queue = deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            curSize = len(queue)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(curSize):</span><br><span class="line">                curNode = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> i == curSize - <span class="number">1</span>:</span><br><span class="line">                    res.append(curNode.val)</span><br><span class="line">                <span class="keyword">if</span> curNode.left:</span><br><span class="line">                    queue.append(curNode.left)</span><br><span class="line">                <span class="keyword">if</span> curNode.right:</span><br><span class="line">                    queue.append(curNode.right)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="Question-5-Binary-Tree-boundary-nodes"><a href="#Question-5-Binary-Tree-boundary-nodes" class="headerlink" title="Question 5: Binary Tree boundary nodes"></a>Question 5: Binary Tree boundary nodes</h3><p>Given a binary tree, return an array containing all the boundary nodes of the tree in an anti-clockwise direction.</p>
<p>The boundary of a tree contains all nodes in the left view, all leaves, and all nodes in the right view. Please note that there should not be any duplicate nodes. For example, the root is only included in the left view; similarly, if a level has only one node we should include it in the left view.</p>
<p><strong>Answer:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_tree_boundary</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        queue = deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        leftView, rightView = [], deque()</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            levelSize = len(queue)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(levelSize):</span><br><span class="line">                curNode = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> curNode.left <span class="keyword">and</span> <span class="keyword">not</span> curNode.right:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">elif</span> i == <span class="number">0</span>:</span><br><span class="line">                    leftView.append(curNode)</span><br><span class="line">                <span class="keyword">elif</span> i == levelSize - <span class="number">1</span>:</span><br><span class="line">                    rightView.appendleft(curNode)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> curNode.left:</span><br><span class="line">                    queue.append(curNode.left)</span><br><span class="line">                <span class="keyword">if</span> curNode.right:</span><br><span class="line">                    queue.append(curNode.right)</span><br><span class="line">        <span class="keyword">return</span> leftView + self.find_leaves_dfs(root) + list(rightView)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_leaves_dfs</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        leaves = []</span><br><span class="line">        queue = deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            curNode = queue.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> curNode.left <span class="keyword">and</span> <span class="keyword">not</span> curNode.right:</span><br><span class="line">                leaves.append(curNode)</span><br><span class="line">            <span class="keyword">if</span> curNode.right:</span><br><span class="line">                queue.append(curNode.right)</span><br><span class="line">            <span class="keyword">if</span> curNode.left:</span><br><span class="line">                queue.append(curNode.left)</span><br><span class="line">        <span class="keyword">return</span> leaves</span><br></pre></td></tr></table></figure>
<h3 id="Question-6-Number-of-Islands"><a href="#Question-6-Number-of-Islands" class="headerlink" title="Question 6: Number of Islands"></a>Question 6: Number of Islands</h3><p>Given a 2d grid map of <code>&#39;1&#39;</code>s (land) and <code>&#39;0&#39;</code>s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>
<p><strong>Answer:</strong></p>
<p>BFS</p>
<p>We can first store all “1” in a set, called s and then loop s. If previous, next, above, below items are also in s, we can remove them. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIslands</span><span class="params">(self, grid: List[List[str]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        s = set([(i, j) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(grid)) <span class="keyword">for</span> j <span class="keyword">in</span> range(len(grid[<span class="number">0</span>])) <span class="keyword">if</span> grid[i][j] == <span class="string">"1"</span>])</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> s:</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">            queue = deque([s.pop()])</span><br><span class="line">            <span class="keyword">while</span> queue:</span><br><span class="line">                i, j = queue.popleft()</span><br><span class="line">                <span class="keyword">for</span> item <span class="keyword">in</span> [(i<span class="number">-1</span>, j), (i+<span class="number">1</span>, j), (i, j<span class="number">-1</span>), (i, j+<span class="number">1</span>)]:</span><br><span class="line">                    <span class="keyword">if</span> item <span class="keyword">in</span> s:</span><br><span class="line">                        s.remove(item)</span><br><span class="line">                        queue.append(item)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>DFS</p>
<p>Idea is similar. Loop the grid, every time finding a “1”, we turn it to “0” and check the above elements: if “1”, turn it. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIslands</span><span class="params">(self, grid: List[List[str]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> range(len(grid)):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> range(len(grid[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> grid[r][c] == <span class="string">"1"</span>:</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">                    self.dfs(grid, r, c)</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, grid, r, c)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= r &lt; len(grid) <span class="keyword">or</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= c&lt; len(grid[<span class="number">0</span>]) <span class="keyword">or</span> grid[r][c] == <span class="string">"0"</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        grid[r][c] = <span class="string">"0"</span></span><br><span class="line">        self.dfs(grid, r+<span class="number">1</span>, c)</span><br><span class="line">        self.dfs(grid, r<span class="number">-1</span>, c)</span><br><span class="line">        self.dfs(grid, r, c+<span class="number">1</span>)</span><br><span class="line">        self.dfs(grid, r, c<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<p>DFS+memo</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIslands</span><span class="params">(self, grid: List[List[str]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        visited = [[<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(grid[<span class="number">0</span>]))] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(grid))]</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> range(len(grid)):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> range(len(grid[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> grid[r][c] == <span class="string">"1"</span> <span class="keyword">and</span> <span class="keyword">not</span> visited[r][c]:</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">                    self.dfs(grid, r, c, visited)</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, grid, r, c, visited)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= r &lt; len(grid) <span class="keyword">or</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= c&lt; len(grid[<span class="number">0</span>]) <span class="keyword">or</span> grid[r][c] == <span class="string">"0"</span> <span class="keyword">or</span> visited[r][c]:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        visited[r][c] = <span class="literal">True</span></span><br><span class="line">        grid[r][c] = <span class="string">"0"</span></span><br><span class="line">        self.dfs(grid, r+<span class="number">1</span>, c, visited)</span><br><span class="line">        self.dfs(grid, r<span class="number">-1</span>, c, visited)</span><br><span class="line">        self.dfs(grid, r, c+<span class="number">1</span>, visited)</span><br><span class="line">        self.dfs(grid, r, c<span class="number">-1</span>, visited)</span><br></pre></td></tr></table></figure>
<h3 id="Question-7-Perfect-Squares"><a href="#Question-7-Perfect-Squares" class="headerlink" title="Question 7: Perfect Squares"></a>Question 7: Perfect Squares</h3><p>Given a positive integer <em>n</em>, find the least number of perfect square numbers (for example, <code>1, 4, 9, 16, ...</code>) which sum to <em>n</em>.</p>
<p><strong>Answer:</strong></p>
<ul>
<li><p>Create two lists, q1=[0], q2=[].</p>
</li>
<li><p>For every elements in q1, we add square numbers to it.</p>
</li>
<li>After adding, if it == n, then we find. If it &lt; n, we continue to add the next square number. If it &gt; n, then we stop.</li>
<li>After looping all number in q1, q1 = q2, q2=[]. And do the above steps again. </li>
<li>Visited is used to avoid overlap computation. </li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSquares</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        q1 = [<span class="number">0</span>]</span><br><span class="line">        q2 = []</span><br><span class="line">        level = <span class="number">0</span></span><br><span class="line">        visited = [<span class="literal">False</span>] * (n+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            level += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> q1:</span><br><span class="line">                i = <span class="number">0</span></span><br><span class="line">                <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                    t = v + i * i</span><br><span class="line">                    <span class="keyword">if</span> t == n:</span><br><span class="line">                        <span class="keyword">return</span> level</span><br><span class="line">                    <span class="keyword">if</span> t &gt; n:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">if</span> visited[t]:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    q2.append(t)</span><br><span class="line">                    visited[t] = <span class="literal">True</span></span><br><span class="line">            q1 = q2</span><br><span class="line">            q2 = []</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="Question-8-Minimum-Height-Trees"><a href="#Question-8-Minimum-Height-Trees" class="headerlink" title="Question 8: Minimum Height Trees"></a>Question 8: Minimum Height Trees</h3><p>For an undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs). Given such a graph, write a function to find all the MHTs and return a list of their root labels.</p>
<p><strong>Format</strong><br>The graph contains <code>n</code> nodes which are labeled from <code>0</code> to <code>n - 1</code>. You will be given the number <code>n</code> and a list of undirected <code>edges</code> (each edge is a pair of labels).</p>
<p>You can assume that no duplicate edges will appear in <code>edges</code>. Since all edges are undirected, <code>[0, 1]</code> is the same as <code>[1, 0]</code> and thus will not appear together in <code>edges</code>.</p>
<p><strong>Answer:</strong></p>
<p>First of all, we should know that leaves can’t be the root of MHT. Because  its adjacent non-leaf node will always give a (height -1) MHT. </p>
<p>Thus, we can removes leaves. After removing, we have new leaves and continue removing until 1 or 2 nodes are left.</p>
<p>It is not possible to have 3 or 4 roots. If 3 are left, one of them will have height=1 and other two will have height=2 and then we actually only have one root. Same idea for 4. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMinHeightTrees</span><span class="params">(self, n: int, edges: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">0</span>]</span><br><span class="line">        inDegree = &#123;i:<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)&#125;</span><br><span class="line">        graph = &#123;i: [] <span class="keyword">for</span> i <span class="keyword">in</span> range(n)&#125;</span><br><span class="line">        <span class="keyword">for</span> edge <span class="keyword">in</span> edges:</span><br><span class="line">            n1, n2 = edge[<span class="number">0</span>], edge[<span class="number">1</span>]</span><br><span class="line">            inDegree[n1] += <span class="number">1</span></span><br><span class="line">            inDegree[n2] += <span class="number">1</span></span><br><span class="line">            graph[n1].append(n2)</span><br><span class="line">            graph[n2].append(n1)</span><br><span class="line">        leaves = deque()</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> inDegree:</span><br><span class="line">            <span class="keyword">if</span> inDegree[key] == <span class="number">1</span>:</span><br><span class="line">                leaves.append(key)</span><br><span class="line">        totalNode = n</span><br><span class="line">        <span class="keyword">while</span> totalNode &gt; <span class="number">2</span>:</span><br><span class="line">            totalNode -= len(leaves)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(leaves)):</span><br><span class="line">                vertex = leaves.popleft()</span><br><span class="line">                <span class="keyword">for</span> child <span class="keyword">in</span> graph[vertex]:</span><br><span class="line">                    inDegree[child] -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> inDegree[child] == <span class="number">1</span>:</span><br><span class="line">                        leaves.append(child)</span><br><span class="line">        <span class="keyword">return</span> list(leaves)</span><br></pre></td></tr></table></figure>
<h3 id="Question-9-Trapping-Rain-Water-II"><a href="#Question-9-Trapping-Rain-Water-II" class="headerlink" title="Question 9: Trapping Rain Water II"></a>Question 9: Trapping Rain Water II</h3><p>Given an <code>m x n</code> matrix of positive integers representing the height of each unit cell in a 2D elevation map, compute the volume of water it is able to trap after raining.</p>
<p><strong>Answers:</strong></p>
<p>We add all surroundings to min_heap. And then we pop from min_heap, which is the least height building right now. Then we check its neighbor whether it can trap water. If yes, we add the water to ans, record it as visited and push (max(h, height of nbr), r, c) to min_heap, cause its neighbor may can trap water. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time: O(m*n*log(m*n))</span></span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trapRainWater</span><span class="params">(self, heightMap: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> heightMap <span class="keyword">or</span> <span class="keyword">not</span> heightMap[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        m, n = len(heightMap), len(heightMap[<span class="number">0</span>])</span><br><span class="line">        heap, visited = [], set()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">0</span>, m<span class="number">-1</span>]:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                heap.append((heightMap[i][j], i, j))</span><br><span class="line">                visited.add((i, j))</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> [<span class="number">0</span>, n<span class="number">-1</span>]:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">                <span class="keyword">if</span> (i, j) <span class="keyword">in</span> visited:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                heap.append((heightMap[i][j], i, j))</span><br><span class="line">                visited.add((i, j))</span><br><span class="line">        </span><br><span class="line">        heapq.heapify(heap)</span><br><span class="line">        directions, ans = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">-1</span>], [<span class="number">-1</span>, <span class="number">0</span>]], <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> heap:</span><br><span class="line">            h, x, y = heapq.heappop(heap)</span><br><span class="line">            <span class="keyword">for</span> dx, dy <span class="keyword">in</span> directions:</span><br><span class="line">                r, c = x + dx, y + dy</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> self.valid(m, n, r, c, visited):</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                ans += max(<span class="number">0</span>, h - heightMap[r][c])</span><br><span class="line">                items = (max(h, heightMap[r][c]), r, c)</span><br><span class="line">                heapq.heappush(heap, items)</span><br><span class="line">                visited.add((r, c))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">valid</span><span class="params">(self, m, n, x, y, visited)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &lt;= x &lt; m <span class="keyword">and</span> <span class="number">0</span> &lt;= y &lt; n <span class="keyword">and</span> (x, y) <span class="keyword">not</span> <span class="keyword">in</span> visited</span><br></pre></td></tr></table></figure>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined" target="_blank" rel="noopener">Pinecone</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://www.pinew.top/2019/12/28/BFS/">https://www.pinew.top/2019/12/28/BFS/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jwu424/Blog_source@master/img/U2En1ED8DLs.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull-left"><a href="/2020/01/06/DFS/"><img class="prev_cover lozad" data-src="https://cdn.jsdelivr.net/gh/jwu424/Blog_source@master/img/7-oM8eFUkFQ.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Previous Post</div><div class="prev_info"><span>DFS</span></div></a></div><div class="next-post pull-right"><a href="/2019/12/26/TwoPointers/"><img class="next_cover lozad" data-src="https://cdn.jsdelivr.net/gh/jwu424/Blog_source@master/img/jH1YFFPBp_I.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Next Post</div><div class="next_info"><span>TwoPointers</span></div></a></div></nav></div></div><footer><div id="footer"><div class="copyright">&copy;2019 - 2020 By Pinecone</div><div class="framework-info"><span>Driven </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">Welcome!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><i class="nightshift fa fa-moon-o" id="nightshift" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="Scroll to comment"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script src="/js/nightshift.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script>const observer = lozad(); // lazy loads elements with default selector as '.lozad'
observer.observe();
</script></body></html>