<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>BinarySearch | Pinecone</title><meta name="description" content="BinarySearch"><meta name="keywords" content=""><meta name="author" content="Pinecone"><meta name="copyright" content="Pinecone"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="https://www.pinew.top/2020/01/16/BinarySearch/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="BinarySearch"><meta name="twitter:description" content="BinarySearch"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jwu424/Blog_source@master/img/U2En1ED8DLs.jpg"><meta property="og:type" content="article"><meta property="og:title" content="BinarySearch"><meta property="og:url" content="https://www.pinew.top/2020/01/16/BinarySearch/"><meta property="og:site_name" content="Pinecone"><meta property="og:description" content="BinarySearch"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/jwu424/Blog_source@master/img/U2En1ED8DLs.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="prev" title="LinkedList" href="https://www.pinew.top/2020/01/20/LinkedList/"><link rel="next" title="DFS" href="https://www.pinew.top/2020/01/06/DFS/"><meta name="google-site-verification" content="google078980f9392d4c28.html"><meta name="baidu-site-verification" content="baidu_verify_4E5F1x6oOR.html"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight_copy: 'true',
  highlight_lang: 'true',
  highlight_shrink: 'true',
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    title: 'Bookmark',
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  copyright: undefined,
  copy_copyright_js: false
  
}</script></head><body><canvas class="fireworks"></canvas><div id="header"> <div id="page-header"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">Pinecone</a></span><i class="fa fa-bars fa-fw toggle-menu pull-right close" aria-hidden="true"></i><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw far fa-image"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/books/"><i class="fa-fw fa fa-book"></i><span> Books</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movies</span></a></li><li><a class="site-page" href="/games/"><i class="fa-fw fa fa-gamepad"></i><span> Games</span></a></li></ul></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lozad avatar_img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">17</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">4</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">Categories</div><div class="length_num">4</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw far fa-image"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/books/"><i class="fa-fw fa fa-book"></i><span> Books</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movies</span></a></li><li><a class="site-page" href="/games/"><i class="fa-fw fa fa-gamepad"></i><span> Games</span></a></li></ul></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">Catalog</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Leetcode-4-Median-of-Two-Sorted-Arrays"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">Leetcode 4 : Median of Two Sorted Arrays</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Leetcode-29-Divide-Two-Integers"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">Leetcode 29: Divide Two Integers</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Leetcode-33-Search-in-Rotated-Sorted-Array"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">Leetcode 33: Search in Rotated Sorted Array</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Leetcode-34-Find-First-and-Last-Position-of-Element-in-Sorted-Array"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">Leetcode 34: Find First and Last Position of Element in Sorted Array</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Leetcode-35-Search-Insert-Position"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">Leetcode 35: Search Insert Position</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Leetcode-50-Pow-x-n"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">Leetcode 50: Pow(x, n)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Leetcode-69-Sqrt-x"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text">Leetcode 69: Sqrt(x)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Leetcode-74-Search-a-2D-Matrix"><span class="toc_mobile_items-number">8.</span> <span class="toc_mobile_items-text">Leetcode 74: Search a 2D Matrix</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Leetcode-81-Search-in-Rotated-Sorted-Array-II"><span class="toc_mobile_items-number">9.</span> <span class="toc_mobile_items-text">Leetcode 81: Search in Rotated Sorted Array II</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Leetcode-153-Find-Minimum-in-Rotated-Sorted-Array"><span class="toc_mobile_items-number">10.</span> <span class="toc_mobile_items-text">Leetcode 153: Find Minimum in Rotated Sorted Array</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Leetcode-154-Find-Minimum-in-Rotated-Sorted-Array-II"><span class="toc_mobile_items-number">11.</span> <span class="toc_mobile_items-text">Leetcode 154: Find Minimum in Rotated Sorted Array II</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Leetcode-162-Find-Peak-Element"><span class="toc_mobile_items-number">12.</span> <span class="toc_mobile_items-text">Leetcode 162: Find Peak Element</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Leetcode-209-Minimum-Size-Subarray-Sum"><span class="toc_mobile_items-number">13.</span> <span class="toc_mobile_items-text">Leetcode 209 : Minimum Size Subarray Sum</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Leetcode-222-Count-Complete-Tree-Nodes"><span class="toc_mobile_items-number">14.</span> <span class="toc_mobile_items-text">Leetcode 222: Count Complete Tree Nodes</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Leetcode-230-Kth-Smallest-Element-in-a-BST"><span class="toc_mobile_items-number">15.</span> <span class="toc_mobile_items-text">Leetcode 230: Kth Smallest Element in a BST</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Leetcode-240-Search-a-2D-Matrix-II"><span class="toc_mobile_items-number">16.</span> <span class="toc_mobile_items-text">Leetcode 240: Search a 2D Matrix II</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Leetcode-275-H-Index-II"><span class="toc_mobile_items-number">17.</span> <span class="toc_mobile_items-text">Leetcode 275: H-Index II</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Leetcode-278-First-Bad-Version"><span class="toc_mobile_items-number">18.</span> <span class="toc_mobile_items-text">Leetcode 278: First Bad Version</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Leetcode-287-Find-the-Duplicate-Number"><span class="toc_mobile_items-number">19.</span> <span class="toc_mobile_items-text">Leetcode 287: Find the Duplicate Number</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Leetcode-300-Longest-Increasing-Subsequence"><span class="toc_mobile_items-number">20.</span> <span class="toc_mobile_items-text">Leetcode 300: Longest Increasing Subsequence</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Leetcode-315-Count-of-Smaller-Numbers-After-Self"><span class="toc_mobile_items-number">21.</span> <span class="toc_mobile_items-text">Leetcode 315: Count of Smaller Numbers After Self</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Leetcode-327-Count-of-Range-Sum"><span class="toc_mobile_items-number">22.</span> <span class="toc_mobile_items-text">Leetcode 327: Count of Range Sum</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Leetcode-354-Russian-Doll-Envelopes"><span class="toc_mobile_items-number">23.</span> <span class="toc_mobile_items-text">Leetcode 354: Russian Doll Envelopes</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Leetcode-367-Valid-Perfect-Square"><span class="toc_mobile_items-number">24.</span> <span class="toc_mobile_items-text">Leetcode 367: Valid Perfect Square</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Leetcode-374-Guess-Number-Higher-or-Lower"><span class="toc_mobile_items-number">25.</span> <span class="toc_mobile_items-text">Leetcode 374: Guess Number Higher or Lower</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Leetcode-378-Kth-Smallest-Element-in-a-Sorted-Matrix"><span class="toc_mobile_items-number">26.</span> <span class="toc_mobile_items-text">Leetcode 378: Kth Smallest Element in a Sorted Matrix</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Leetcode-392-Is-Subsequence"><span class="toc_mobile_items-number">27.</span> <span class="toc_mobile_items-text">Leetcode 392: Is Subsequence</span></a></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-4-Median-of-Two-Sorted-Arrays"><span class="toc-number">1.</span> <span class="toc-text">Leetcode 4 : Median of Two Sorted Arrays</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-29-Divide-Two-Integers"><span class="toc-number">2.</span> <span class="toc-text">Leetcode 29: Divide Two Integers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-33-Search-in-Rotated-Sorted-Array"><span class="toc-number">3.</span> <span class="toc-text">Leetcode 33: Search in Rotated Sorted Array</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-34-Find-First-and-Last-Position-of-Element-in-Sorted-Array"><span class="toc-number">4.</span> <span class="toc-text">Leetcode 34: Find First and Last Position of Element in Sorted Array</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-35-Search-Insert-Position"><span class="toc-number">5.</span> <span class="toc-text">Leetcode 35: Search Insert Position</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-50-Pow-x-n"><span class="toc-number">6.</span> <span class="toc-text">Leetcode 50: Pow(x, n)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-69-Sqrt-x"><span class="toc-number">7.</span> <span class="toc-text">Leetcode 69: Sqrt(x)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-74-Search-a-2D-Matrix"><span class="toc-number">8.</span> <span class="toc-text">Leetcode 74: Search a 2D Matrix</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-81-Search-in-Rotated-Sorted-Array-II"><span class="toc-number">9.</span> <span class="toc-text">Leetcode 81: Search in Rotated Sorted Array II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-153-Find-Minimum-in-Rotated-Sorted-Array"><span class="toc-number">10.</span> <span class="toc-text">Leetcode 153: Find Minimum in Rotated Sorted Array</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-154-Find-Minimum-in-Rotated-Sorted-Array-II"><span class="toc-number">11.</span> <span class="toc-text">Leetcode 154: Find Minimum in Rotated Sorted Array II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-162-Find-Peak-Element"><span class="toc-number">12.</span> <span class="toc-text">Leetcode 162: Find Peak Element</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-209-Minimum-Size-Subarray-Sum"><span class="toc-number">13.</span> <span class="toc-text">Leetcode 209 : Minimum Size Subarray Sum</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-222-Count-Complete-Tree-Nodes"><span class="toc-number">14.</span> <span class="toc-text">Leetcode 222: Count Complete Tree Nodes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-230-Kth-Smallest-Element-in-a-BST"><span class="toc-number">15.</span> <span class="toc-text">Leetcode 230: Kth Smallest Element in a BST</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-240-Search-a-2D-Matrix-II"><span class="toc-number">16.</span> <span class="toc-text">Leetcode 240: Search a 2D Matrix II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-275-H-Index-II"><span class="toc-number">17.</span> <span class="toc-text">Leetcode 275: H-Index II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-278-First-Bad-Version"><span class="toc-number">18.</span> <span class="toc-text">Leetcode 278: First Bad Version</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-287-Find-the-Duplicate-Number"><span class="toc-number">19.</span> <span class="toc-text">Leetcode 287: Find the Duplicate Number</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-300-Longest-Increasing-Subsequence"><span class="toc-number">20.</span> <span class="toc-text">Leetcode 300: Longest Increasing Subsequence</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-315-Count-of-Smaller-Numbers-After-Self"><span class="toc-number">21.</span> <span class="toc-text">Leetcode 315: Count of Smaller Numbers After Self</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-327-Count-of-Range-Sum"><span class="toc-number">22.</span> <span class="toc-text">Leetcode 327: Count of Range Sum</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-354-Russian-Doll-Envelopes"><span class="toc-number">23.</span> <span class="toc-text">Leetcode 354: Russian Doll Envelopes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-367-Valid-Perfect-Square"><span class="toc-number">24.</span> <span class="toc-text">Leetcode 367: Valid Perfect Square</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-374-Guess-Number-Higher-or-Lower"><span class="toc-number">25.</span> <span class="toc-text">Leetcode 374: Guess Number Higher or Lower</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-378-Kth-Smallest-Element-in-a-Sorted-Matrix"><span class="toc-number">26.</span> <span class="toc-text">Leetcode 378: Kth Smallest Element in a Sorted Matrix</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-392-Is-Subsequence"><span class="toc-number">27.</span> <span class="toc-text">Leetcode 392: Is Subsequence</span></a></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/jwu424/Blog_source@master/img/U2En1ED8DLs.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">BinarySearch</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> Created 2020-01-16<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> Updated 2020-01-20</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Leetcode/">Leetcode</a></span><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">4.3k</span><span class="post-meta__separator">|</span><span>Reading time: 27 min</span><span class="post-meta__separator">|</span><span>Post View: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h3 id="Leetcode-4-Median-of-Two-Sorted-Arrays"><a href="#Leetcode-4-Median-of-Two-Sorted-Arrays" class="headerlink" title="Leetcode 4 : Median of Two Sorted Arrays"></a>Leetcode 4 : Median of Two Sorted Arrays</h3><p>There are two sorted arrays <strong>nums1</strong> and <strong>nums2</strong> of size m and n respectively.</p>
<p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>
<p>You may assume <strong>nums1</strong> and <strong>nums2</strong> cannot be both empty.</p>
<p><strong>Answer:</strong></p>
<p>Each time, we ignore half of k by comparing two lists. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time: O(Log(N+M))</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1: List[int], nums2: List[int])</span> -&gt; float:</span></span><br><span class="line">        l = len(nums1) + len(nums2)</span><br><span class="line">        <span class="keyword">if</span> l % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.find(nums1, nums2, l//<span class="number">2</span>+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (self.find(nums1, nums2, l//<span class="number">2</span>) + self.find(nums1, nums2, l//<span class="number">2</span>+<span class="number">1</span>))*<span class="number">0.5</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, nums1, nums2, k)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums1) &gt; len(nums2):</span><br><span class="line">            nums1, nums2 = nums2, nums1</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums1:</span><br><span class="line">            <span class="keyword">return</span> nums2[k<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> min(nums1[<span class="number">0</span>], nums2[<span class="number">0</span>])</span><br><span class="line">        k1 = min(k//<span class="number">2</span>, len(nums1))</span><br><span class="line">        k2 = k - k1</span><br><span class="line">        <span class="keyword">if</span> nums1[k1<span class="number">-1</span>] &lt;= nums2[k2<span class="number">-1</span>]:</span><br><span class="line">            <span class="keyword">return</span> self.find(nums1[k1:], nums2, k-k1)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.find(nums1, nums2[k2:], k-k2)</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-29-Divide-Two-Integers"><a href="#Leetcode-29-Divide-Two-Integers" class="headerlink" title="Leetcode 29: Divide Two Integers"></a>Leetcode 29: Divide Two Integers</h3><p>Given two integers <code>dividend</code> and <code>divisor</code>, divide two integers without using multiplication, division and mod operator.</p>
<p>Return the quotient after dividing <code>dividend</code> by <code>divisor</code>.</p>
<p>The integer division should truncate toward zero.</p>
<ul>
<li>Both dividend and divisor will be 32-bit signed integers.</li>
<li>The divisor will never be 0.</li>
<li>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 231 − 1 when the division result overflows.</li>
</ul>
<p><strong>Answer:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(self, dividend: int, divisor: int)</span> -&gt; int:</span></span><br><span class="line">        intMax, intMin = <span class="number">2147483647</span>, <span class="number">-2147483648</span></span><br><span class="line">        <span class="keyword">if</span> dividend == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        negative = (dividend &gt; <span class="number">0</span>) ^ (divisor &gt; <span class="number">0</span>)</span><br><span class="line">        dividend, divisor = abs(dividend), abs(divisor)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> dividend &gt;= divisor:</span><br><span class="line">            temp = <span class="number">1</span></span><br><span class="line">            x = divisor</span><br><span class="line">            <span class="keyword">while</span> dividend &gt;= x + x:</span><br><span class="line">                x += x</span><br><span class="line">                temp += temp</span><br><span class="line">            res += temp</span><br><span class="line">            dividend -= x</span><br><span class="line">        <span class="keyword">return</span> max(-res, intMin) <span class="keyword">if</span> negative <span class="keyword">else</span> min(res, intMax)</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-33-Search-in-Rotated-Sorted-Array"><a href="#Leetcode-33-Search-in-Rotated-Sorted-Array" class="headerlink" title="Leetcode 33: Search in Rotated Sorted Array"></a>Leetcode 33: Search in Rotated Sorted Array</h3><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., <code>[0,1,2,4,5,6,7]</code> might become <code>[4,5,6,7,0,1,2]</code>).</p>
<p>You are given a target value to search. If found in the array return its index, otherwise return <code>-1</code>.</p>
<p>You may assume no duplicate exists in the array.</p>
<p>Your algorithm’s runtime complexity must be in the order of <em>O</em>(log <em>n</em>).</p>
<p><strong>Answer:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time: O(LogN)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        left, right = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">if</span> nums[left] &lt;= nums[mid]:</span><br><span class="line">                <span class="comment"># If left part is sorted. </span></span><br><span class="line">                <span class="keyword">if</span> target &gt;= nums[left] <span class="keyword">and</span> target &lt; nums[mid]:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># If right part is sorted.</span></span><br><span class="line">                <span class="keyword">if</span> target &gt; nums[mid] <span class="keyword">and</span> target &lt;= nums[right]:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-34-Find-First-and-Last-Position-of-Element-in-Sorted-Array"><a href="#Leetcode-34-Find-First-and-Last-Position-of-Element-in-Sorted-Array" class="headerlink" title="Leetcode 34: Find First and Last Position of Element in Sorted Array"></a>Leetcode 34: Find First and Last Position of Element in Sorted Array</h3><p>Given an array of integers <code>nums</code> sorted in ascending order, find the starting and ending position of a given <code>target</code> value.</p>
<p>Your algorithm’s runtime complexity must be in the order of <em>O</em>(log <em>n</em>).</p>
<p>If the target is not found in the array, return <code>[-1, -1]</code>.</p>
<p><strong>Answer:</strong></p>
<p>Classic Binary Search problem. Only need to change the codes when we get the target. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time:O(logN)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">-1</span>, <span class="number">-1</span>]</span><br><span class="line">        left, right = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                t_left, t_right = mid, mid</span><br><span class="line">                <span class="keyword">while</span> t_left &gt; <span class="number">0</span> <span class="keyword">and</span> nums[t_left<span class="number">-1</span>] == target:</span><br><span class="line">                    t_left -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> t_right &lt; len(nums) - <span class="number">1</span> <span class="keyword">and</span> nums[t_right+<span class="number">1</span>] == target:</span><br><span class="line">                    t_right += <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> [t_left, t_right]</span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="number">-1</span>, <span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-35-Search-Insert-Position"><a href="#Leetcode-35-Search-Insert-Position" class="headerlink" title="Leetcode 35: Search Insert Position"></a>Leetcode 35: Search Insert Position</h3><p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>
<p>You may assume no duplicates in the array.</p>
<p><strong>Answer:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left, right = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-50-Pow-x-n"><a href="#Leetcode-50-Pow-x-n" class="headerlink" title="Leetcode 50: Pow(x, n)"></a>Leetcode 50: Pow(x, n)</h3><p>Implement <a href="http://www.cplusplus.com/reference/valarray/pow/" target="_blank" rel="noopener">pow(<em>x</em>, <em>n</em>)</a>, which calculates <em>x</em> raised to the power n.</p>
<p><strong>Answer:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time: O(logN)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x: float, n: int)</span> -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> / self.findPower(x, -n)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.findPower(x, n)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPower</span><span class="params">(self, x, n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        temp = self.findPower(x, n // <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> temp * temp</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> temp * temp * x</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-69-Sqrt-x"><a href="#Leetcode-69-Sqrt-x" class="headerlink" title="Leetcode 69: Sqrt(x)"></a>Leetcode 69: Sqrt(x)</h3><p>Implement <code>int sqrt(int x)</code>.</p>
<p>Compute and return the square root of <em>x</em>, where <em>x</em> is guaranteed to be a non-negative integer.</p>
<p>Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.</p>
<p><strong>Answer:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time: O(LogN)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line">        left, right = <span class="number">0</span>, x</span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            temp = mid * mid</span><br><span class="line">            <span class="keyword">if</span> temp == x:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> temp &lt; x:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> right</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-74-Search-a-2D-Matrix"><a href="#Leetcode-74-Search-a-2D-Matrix" class="headerlink" title="Leetcode 74: Search a 2D Matrix"></a>Leetcode 74: Search a 2D Matrix</h3><p>Write an efficient algorithm that searches for a value in an <em>m</em> x <em>n</em> matrix. This matrix has the following properties:</p>
<ul>
<li>Integers in each row are sorted from left to right.</li>
<li>The first integer of each row is greater than the last integer of the previous row.</li>
</ul>
<p><strong>Answer:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time: O(LogMN)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span><span class="params">(self, matrix: List[List[int]], target: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> <span class="keyword">not</span> matrix[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        row, col = len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line">        left, right = <span class="number">0</span>, row * col - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left)//<span class="number">2</span></span><br><span class="line">            num = matrix[mid // col][mid % col]</span><br><span class="line">            <span class="keyword">if</span> num == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> num &lt; target:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-81-Search-in-Rotated-Sorted-Array-II"><a href="#Leetcode-81-Search-in-Rotated-Sorted-Array-II" class="headerlink" title="Leetcode 81: Search in Rotated Sorted Array II"></a>Leetcode 81: Search in Rotated Sorted Array II</h3><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., <code>[0,0,1,2,2,5,6]</code> might become <code>[2,5,6,0,0,1,2]</code>).</p>
<p>You are given a target value to search. If found in the array return <code>true</code>, otherwise return <code>false</code>.</p>
<p><strong>Answer:</strong></p>
<p>The only difference is that if nums[left] == nums[mid] == nums[right], it is hard for us to distinguish which part is sorted. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time: O(LogN). Worst: O(N)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        left, right = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> nums[left] == nums[mid] <span class="keyword">and</span> nums[right] == nums[mid]:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[left] &lt;= nums[mid]:</span><br><span class="line">                <span class="keyword">if</span> nums[left] &lt;= target &lt; nums[mid]:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt; target &lt;= nums[right]:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-153-Find-Minimum-in-Rotated-Sorted-Array"><a href="#Leetcode-153-Find-Minimum-in-Rotated-Sorted-Array" class="headerlink" title="Leetcode 153: Find Minimum in Rotated Sorted Array"></a>Leetcode 153: Find Minimum in Rotated Sorted Array</h3><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e.,  <code>[0,1,2,4,5,6,7]</code> might become  <code>[4,5,6,7,0,1,2]</code>).</p>
<p>Find the minimum element.</p>
<p>You may assume no duplicate exists in the array.</p>
<p><strong>Answer:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time: O(logN)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        left, right = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt;= nums[right]:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># nums[mid] may be the smallest one, so we can't use mid - 1</span></span><br><span class="line">                right = mid</span><br><span class="line">        <span class="keyword">return</span> nums[right]</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-154-Find-Minimum-in-Rotated-Sorted-Array-II"><a href="#Leetcode-154-Find-Minimum-in-Rotated-Sorted-Array-II" class="headerlink" title="Leetcode 154: Find Minimum in Rotated Sorted Array II"></a>Leetcode 154: Find Minimum in Rotated Sorted Array II</h3><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e.,  <code>[0,1,2,4,5,6,7]</code> might become  <code>[4,5,6,7,0,1,2]</code>).</p>
<p>Find the minimum element.</p>
<p>The array may contain duplicates.</p>
<p><strong>Answer:</strong></p>
<p>Only need to care about the situation that <code>nums[mid] == nums[left]</code>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        left, right = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; nums[right]:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; nums[right]:</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums[right]</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-162-Find-Peak-Element"><a href="#Leetcode-162-Find-Peak-Element" class="headerlink" title="Leetcode 162: Find Peak Element"></a>Leetcode 162: Find Peak Element</h3><p>A peak element is an element that is greater than its neighbors.</p>
<p>Given an input array <code>nums</code>, where <code>nums[i] ≠ nums[i+1]</code>, find a peak element and return its index.</p>
<p>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.</p>
<p>You may imagine that <code>nums[-1] = nums[n] = -∞</code>.</p>
<p><strong>Answer:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPeakElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        left, right = <span class="number">0</span>, len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            <span class="keyword">if</span> left == right:</span><br><span class="line">                <span class="keyword">return</span> left</span><br><span class="line">            mid = (left + right)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; nums[mid+<span class="number">1</span>]:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid</span><br><span class="line">        <span class="keyword">return</span> mid</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-209-Minimum-Size-Subarray-Sum"><a href="#Leetcode-209-Minimum-Size-Subarray-Sum" class="headerlink" title="Leetcode 209 : Minimum Size Subarray Sum"></a>Leetcode 209 : Minimum Size Subarray Sum</h3><p>Given an array of <strong>n</strong> positive integers and a positive integer <strong>s</strong>, find the minimal length of a <strong>contiguous</strong> subarray of which the sum ≥ <strong>s</strong>. If there isn’t one, return 0 instead.</p>
<p><strong>Answer:</strong></p>
<p>It is a sliding window problem, but also can be solved by binary search.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSubArrayLen</span><span class="params">(self, s: int, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        res = len(nums) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            nums[i] += nums[i<span class="number">-1</span>]</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> right, val <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> val &gt;= s:</span><br><span class="line">                left = self.findLeft(nums, left, right, s, val)</span><br><span class="line">                res = min(res, right - left + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> res &lt;= len(nums) <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLeft</span><span class="params">(self, nums, left, right, s, val)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right - left)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> val - nums[mid] &gt;= s:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid</span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-222-Count-Complete-Tree-Nodes"><a href="#Leetcode-222-Count-Complete-Tree-Nodes" class="headerlink" title="Leetcode 222: Count Complete Tree Nodes"></a>Leetcode 222: Count Complete Tree Nodes</h3><p>Given a <strong>complete</strong> binary tree, count the number of nodes.</p>
<p>In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.</p>
<p><strong>Answer:</strong></p>
<p>Since the missing part is in the last level and all nodes are as far left as possible. We can compare height of node.left and node.right for each node. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time: O(LogN**2)</span></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countNodes</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        h1, h2 = self.height(root.left), self.height(root.right)</span><br><span class="line">        <span class="comment"># h1 &gt; h2 means the missing part of last node is in root.left</span></span><br><span class="line">        <span class="keyword">if</span> h1 &gt; h2:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span> ** h2 + self.countNodes(root.left)</span><br><span class="line">        <span class="comment"># h1 = h2 means the missing part is in root.right</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span> ** h1 + self.countNodes(root.right)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">height</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># Since all nodes in the last level are as far left as possible, we need to </span></span><br><span class="line">        <span class="comment"># use root.left to calculate the height of tree.</span></span><br><span class="line">        <span class="keyword">return</span> self.height(root.left) + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-230-Kth-Smallest-Element-in-a-BST"><a href="#Leetcode-230-Kth-Smallest-Element-in-a-BST" class="headerlink" title="Leetcode 230: Kth Smallest Element in a BST"></a>Leetcode 230: Kth Smallest Element in a BST</h3><p>Given a binary search tree, write a function <code>kthSmallest</code> to find the <strong>k</strong>th smallest element in it.</p>
<p><strong>Note:</strong><br>You may assume k is always valid, 1 ≤ k ≤ BST’s total elements.</p>
<p><strong>Answer:</strong></p>
<p>Use inorder to traversal the tree.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, root: TreeNode, k: int)</span> -&gt; int:</span></span><br><span class="line">        self.k = k</span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line">        self.helper(root)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            self.helper(root.left)</span><br><span class="line">            self.k -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.k == <span class="number">0</span>:</span><br><span class="line">                self.res = root.val</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            self.helper(root.right)</span><br></pre></td></tr></table></figure>
<p>Using stack.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, root: TreeNode, k: int)</span> -&gt; int:</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            node = stack.pop()</span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> node.val</span><br><span class="line">            root = node.right</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-240-Search-a-2D-Matrix-II"><a href="#Leetcode-240-Search-a-2D-Matrix-II" class="headerlink" title="Leetcode 240: Search a 2D Matrix II"></a>Leetcode 240: Search a 2D Matrix II</h3><p>Write an efficient algorithm that searches for a value in an <em>m</em> x <em>n</em> matrix. This matrix has the following properties:</p>
<ul>
<li>Integers in each row are sorted in ascending from left to right.</li>
<li>Integers in each column are sorted in ascending from top to bottom.</li>
</ul>
<p>Write an efficient algorithm that searches for a value in an <em>m</em> x <em>n</em> matrix. This matrix has the following properties:</p>
<ul>
<li>Integers in each row are sorted in ascending from left to right.</li>
<li>Integers in each column are sorted in ascending from top to bottom.</li>
</ul>
<p><strong>Answer:</strong></p>
<p>We can start from bottom left and compare with target. </p>
<p>If cur &lt; target, col += 1</p>
<p>Else, row -= 1</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time: O(n+m)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span><span class="params">(self, matrix, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m = len(matrix)</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        n = len(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        y = m - <span class="number">1</span></span><br><span class="line">        x = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> x &lt; n <span class="keyword">and</span> y &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> matrix[y][x] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> matrix[y][x] &lt; target:</span><br><span class="line">                x += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                y -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-275-H-Index-II"><a href="#Leetcode-275-H-Index-II" class="headerlink" title="Leetcode 275: H-Index II"></a>Leetcode 275: H-Index II</h3><p>Given an array of citations <strong>sorted in ascending order</strong> (each citation is a non-negative integer) of a researcher, write a function to compute the researcher’s h-index.</p>
<p>According to the <a href="https://en.wikipedia.org/wiki/H-index" target="_blank" rel="noopener">definition of h-index on Wikipedia</a>: “A scientist has index <em>h</em> if <em>h</em> of his/her <em>N</em> papers have <strong>at least</strong> <em>h</em> citations each, and the other <em>N − h</em> papers have <strong>no more than</strong> <em>h</em> citations each.”</p>
<p><strong>Answer:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hIndex</span><span class="params">(self, citations: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> citations:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(citations)</span><br><span class="line">        left, right = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> citations[mid] == n - mid:</span><br><span class="line">                <span class="keyword">return</span> n - mid</span><br><span class="line">            <span class="keyword">elif</span> citations[mid] &gt; n - mid:</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> min(citations[left], n - left)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hIndex</span><span class="params">(self, citations: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> citations:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(citations)</span><br><span class="line">        left, right = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> citations[mid] &gt;= n - mid:</span><br><span class="line">                res = n - mid</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-278-First-Bad-Version"><a href="#Leetcode-278-First-Bad-Version" class="headerlink" title="Leetcode 278: First Bad Version"></a>Leetcode 278: First Bad Version</h3><p>You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.</p>
<p>Suppose you have <code>n</code> versions <code>[1, 2, ..., n]</code> and you want to find out the first bad one, which causes all the following ones to be bad.</p>
<p>You are given an API <code>bool isBadVersion(version)</code> which will return whether <code>version</code> is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.</p>
<p><strong>Answer:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The isBadVersion API is already defined for you.</span></span><br><span class="line"><span class="comment"># @param version, an integer</span></span><br><span class="line"><span class="comment"># @return a bool</span></span><br><span class="line"><span class="comment"># def isBadVersion(version):</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstBadVersion</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left, right = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> isBadVersion(mid):</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-287-Find-the-Duplicate-Number"><a href="#Leetcode-287-Find-the-Duplicate-Number" class="headerlink" title="Leetcode 287: Find the Duplicate Number"></a>Leetcode 287: Find the Duplicate Number</h3><p>Given an array <em>nums</em> containing <em>n</em> + 1 integers where each integer is between 1 and <em>n</em> (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.</p>
<p><strong>Answer:</strong></p>
<p>We can compare mid with the number of values in nums which are smaller than mid. If count &gt; mid, then the duplicate one is less than or equal to mid, then we can set right = mid. Else, the duplicate is larger than mid, we can set left = mid + 1.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findDuplicate</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left, right = <span class="number">1</span>, len(nums)</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> x &lt;= mid:</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> count &gt; mid:</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-300-Longest-Increasing-Subsequence"><a href="#Leetcode-300-Longest-Increasing-Subsequence" class="headerlink" title="Leetcode 300: Longest Increasing Subsequence"></a>Leetcode 300: Longest Increasing Subsequence</h3><p>Given an unsorted array of integers, find the length of longest increasing subsequence.</p>
<p><strong>Answer:</strong></p>
<p>We can create a list of record and for each elem in nums, we compare current elem with previous.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time: O(N^2)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        record = [<span class="number">1</span>] * len(nums)</span><br><span class="line">        maxlen = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> nums[j] &lt; nums[i]:</span><br><span class="line">                    record[i] = max(record[i], record[j] + <span class="number">1</span>)</span><br><span class="line">            maxlen = max(maxlen, record[i])</span><br><span class="line">        <span class="keyword">return</span> maxlen</span><br></pre></td></tr></table></figure>
<ul>
<li>Create an empty res.</li>
<li>Loop nums<ul>
<li>If res is empty or num &gt; res[-1], we add num to res.</li>
<li>Else, we try to replace one element in res with num. </li>
<li>Ex: [2, 5] —-&gt; [2, 3]</li>
</ul>
</li>
<li>More detail can be found in the following link:</li>
<li><a href="https://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time: O(NlogN)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> res <span class="keyword">or</span> num &gt; res[<span class="number">-1</span>]:</span><br><span class="line">                res.append(num)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left, right = <span class="number">0</span>, len(res) - <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                    mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">                    <span class="keyword">if</span> res[mid] &lt; num:</span><br><span class="line">                        left = mid + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        right = mid</span><br><span class="line">                res[left] = num</span><br><span class="line">        <span class="keyword">return</span> len(res)</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-315-Count-of-Smaller-Numbers-After-Self"><a href="#Leetcode-315-Count-of-Smaller-Numbers-After-Self" class="headerlink" title="Leetcode 315: Count of Smaller Numbers After Self"></a>Leetcode 315: Count of Smaller Numbers After Self</h3><p>You are given an integer array <em>nums</em> and you have to return a new <em>counts</em> array. The <em>counts</em> array has the property where <code>counts[i]</code> is the number of smaller elements to the right of <code>nums[i]</code>.</p>
<p><strong>Answer:</strong></p>
<p>Binary Search:</p>
<ul>
<li>Create empty res and arr list. </li>
<li>Loop from right to left.<ul>
<li>Use binary search to find the index of num if we want to insert it into arr. the idx is the count of number.</li>
<li>Append index to res and insert num into arr.</li>
</ul>
</li>
<li>Return inverse res. </li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time: O(NlogN)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSmaller</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        res, arr = [], []</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums[::<span class="number">-1</span>]:</span><br><span class="line">            idx = self.find(arr, num)</span><br><span class="line">            res.append(idx)</span><br><span class="line">            arr.insert(idx, num)</span><br><span class="line">        <span class="keyword">return</span> res[::<span class="number">-1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, arr, num)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> arr:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left, right = <span class="number">0</span>, len(arr) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> arr[mid] &lt; num:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-327-Count-of-Range-Sum"><a href="#Leetcode-327-Count-of-Range-Sum" class="headerlink" title="Leetcode 327: Count of Range Sum"></a>Leetcode 327: Count of Range Sum</h3><p>Given an integer array <code>nums</code>, return the number of range sums that lie in <code>[lower, upper]</code> inclusive.<br>Range sum <code>S(i, j)</code> is defined as the sum of the elements in <code>nums</code> between indices <code>i</code> and <code>j</code> (<code>i</code> ≤ <code>j</code>), inclusive.</p>
<p><strong>Note:</strong><br>A naive algorithm of <em>O</em>(<em>n</em>2) is trivial. You MUST do better than that.</p>
<p><strong>Answer:</strong></p>
<p>We can compute the prefix sum of current index. Ex: for index i, get nums[:I].</p>
<p>Then we just need to check whether cumsum[j] - cumsum[i] in [lower, upper].</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time: O(N*(upper-lower+1))</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countRangeSum</span><span class="params">(self, nums: List[int], lower: int, upper: int)</span> -&gt; int:</span></span><br><span class="line">        cumsum = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            cumsum.append(cumsum[<span class="number">-1</span>] + num)</span><br><span class="line">        record = &#123;&#125;</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> cum <span class="keyword">in</span> cumsum:</span><br><span class="line">            <span class="keyword">for</span> target <span class="keyword">in</span> range(lower, upper+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> cum - target <span class="keyword">in</span> record:</span><br><span class="line">                    res += record[cum - target]</span><br><span class="line">            record[cum] = record.get(cum, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>MergeSort.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-354-Russian-Doll-Envelopes"><a href="#Leetcode-354-Russian-Doll-Envelopes" class="headerlink" title="Leetcode 354: Russian Doll Envelopes"></a>Leetcode 354: Russian Doll Envelopes</h3><p>You have a number of envelopes with widths and heights given as a pair of integers <code>(w, h)</code>. One envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope.</p>
<p>What is the maximum number of envelopes can you Russian doll? (put one inside other)</p>
<p><strong>Note:</strong><br>Rotation is not allowed.</p>
<p><strong>Answer:</strong></p>
<p>DP: same as leetcode 300.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time: O(N^2)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxEnvelopes</span><span class="params">(self, envelopes: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> envelopes:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        envelopes.sort()</span><br><span class="line">        dp = [<span class="number">0</span>] * len(envelopes)</span><br><span class="line">        dp[<span class="number">0</span>], res = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(envelopes)):</span><br><span class="line">            temp = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, i):</span><br><span class="line">                <span class="keyword">if</span> envelopes[i][<span class="number">0</span>] &gt; envelopes[j][<span class="number">0</span>] <span class="keyword">and</span> envelopes[i][<span class="number">1</span>] &gt; envelopes[j][<span class="number">1</span>]:</span><br><span class="line">                    temp = max(temp, dp[j])</span><br><span class="line">            dp[i] = temp + <span class="number">1</span></span><br><span class="line">            res = max(res, dp[i])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>same as leetcode 300.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time: O(NlogN)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxEnvelopes</span><span class="params">(self, envelopes: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> envelopes:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        envelopes.sort(key=<span class="keyword">lambda</span> x:(x[<span class="number">0</span>],-x[<span class="number">1</span>]))</span><br><span class="line">        h = []</span><br><span class="line">        <span class="keyword">for</span> i, env <span class="keyword">in</span> enumerate(envelopes):</span><br><span class="line">            index = bisect.bisect_left(h, env[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> index &lt; len(h):</span><br><span class="line">                h[index] = env[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                h.append(env[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> len(h)</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-367-Valid-Perfect-Square"><a href="#Leetcode-367-Valid-Perfect-Square" class="headerlink" title="Leetcode 367: Valid Perfect Square"></a>Leetcode 367: Valid Perfect Square</h3><p>Given a positive integer <em>num</em>, write a function which returns True if <em>num</em> is a perfect square else False.</p>
<p><strong>Note:</strong> <strong>Do not</strong> use any built-in library function such as <code>sqrt</code>.</p>
<p><strong>Answer:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time: O(logN)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPerfectSquare</span><span class="params">(self, num: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">0</span> <span class="keyword">or</span> num == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        cur = num // <span class="number">2</span></span><br><span class="line">        left, right = <span class="number">1</span>, cur</span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            temp = mid * mid</span><br><span class="line">            <span class="keyword">if</span> temp == num:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> temp &lt; num:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-374-Guess-Number-Higher-or-Lower"><a href="#Leetcode-374-Guess-Number-Higher-or-Lower" class="headerlink" title="Leetcode 374: Guess Number Higher or Lower"></a>Leetcode 374: Guess Number Higher or Lower</h3><p>We are playing the Guess Game. The game is as follows:</p>
<p>I pick a number from <strong>1</strong> to <strong><em>n\</em></strong>. You have to guess which number I picked.</p>
<p>Every time you guess wrong, I’ll tell you whether the number is higher or lower.</p>
<p>You call a pre-defined API <code>guess(int num)</code> which returns 3 possible results (<code>-1</code>, <code>1</code>, or <code>0</code>):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-1 : My number is lower</span><br><span class="line"> 1 : My number is higher</span><br><span class="line"> 0 : Congrats! You got it!</span><br></pre></td></tr></table></figure>
<p><strong>Answer:</strong></p>
<p>Be careful, ‘My number is higher’ means the number we pick is smaller than actual one. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The guess API is already defined for you.</span></span><br><span class="line"><span class="comment"># @return -1 if my number is lower, 1 if my number is higher, otherwise return 0</span></span><br><span class="line"><span class="comment"># def guess(num: int) -&gt; int:</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">guessNumber</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        left, right = <span class="number">1</span>, n</span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            g = guess(mid)</span><br><span class="line">            print(mid, g)</span><br><span class="line">            <span class="keyword">if</span> g == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> g == <span class="number">1</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-378-Kth-Smallest-Element-in-a-Sorted-Matrix"><a href="#Leetcode-378-Kth-Smallest-Element-in-a-Sorted-Matrix" class="headerlink" title="Leetcode 378: Kth Smallest Element in a Sorted Matrix"></a>Leetcode 378: Kth Smallest Element in a Sorted Matrix</h3><p>Given a <em>n</em> x <em>n</em> matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.</p>
<p>Note that it is the kth smallest element in the sorted order, not the kth distinct element.</p>
<p><strong>Answer:</strong></p>
<p>We can use minHeap to solve the problem. Heappush the first elem of each row into minHeap. Whenever we pop one element, we add the next element in that row until we get the Kth element. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time: O(NlogK)</span></span><br><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, matrix: List[List[int]], k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> <span class="keyword">not</span> matrix[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        minHeap = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix)):</span><br><span class="line">            heappush(minHeap, (matrix[i][<span class="number">0</span>], <span class="number">0</span>, i))</span><br><span class="line">        count, number = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> minHeap:</span><br><span class="line">            number, col, row = heappop(minHeap)</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> count == k:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> col &lt; len(matrix[<span class="number">0</span>])<span class="number">-1</span>:</span><br><span class="line">                heappush(minHeap, (matrix[row][col+<span class="number">1</span>], col+<span class="number">1</span>, row))</span><br><span class="line">        <span class="keyword">return</span> number</span><br></pre></td></tr></table></figure>
<p>Binary Search</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, matrix: List[List[int]], k: int)</span> -&gt; int:</span></span><br><span class="line">        rows = cols = len(matrix)</span><br><span class="line">        left, right = matrix[<span class="number">0</span>][<span class="number">0</span>], matrix[<span class="number">-1</span>][<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> self.count_less(matrix, cols, mid) &lt; k:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">count_less</span><span class="params">(self, matrix, cols, mid)</span>:</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        col = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> reversed(matrix):</span><br><span class="line">            <span class="keyword">while</span> col &lt; cols <span class="keyword">and</span> row[col] &lt;= mid:</span><br><span class="line">                col += <span class="number">1</span></span><br><span class="line">            count += col</span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-392-Is-Subsequence"><a href="#Leetcode-392-Is-Subsequence" class="headerlink" title="Leetcode 392: Is Subsequence"></a>Leetcode 392: Is Subsequence</h3><p>Given a string <strong>s</strong> and a string <strong>t</strong>, check if <strong>s</strong> is subsequence of <strong>t</strong>.</p>
<p>You may assume that there is only lower case English letters in both <strong>s</strong> and <strong>t</strong>. <strong>t</strong> is potentially a very long (length ~= 500,000) string, and <strong>s</strong> is a short string (&lt;=100).</p>
<p>A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, <code>&quot;ace&quot;</code> is a subsequence of <code>&quot;abcde&quot;</code> while <code>&quot;aec&quot;</code> is not).</p>
<p><strong>Answer:</strong></p>
<p>Greedy:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time:O(T)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubsequence</span><span class="params">(self, s: str, t: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> (<span class="keyword">not</span> s <span class="keyword">and</span> <span class="keyword">not</span> t):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> t:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        p1, p2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p1 &lt; len(s) <span class="keyword">and</span> p2 &lt; len(t):</span><br><span class="line">            <span class="keyword">if</span> s[p1] == t[p2]:</span><br><span class="line">                p1 += <span class="number">1</span></span><br><span class="line">                p2 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p2 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> p1 == len(s)</span><br></pre></td></tr></table></figure>
<p>Binary Search</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time :O(T+SlogT)</span></span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubsequence</span><span class="params">(self, s: str, t: str)</span> -&gt; bool:</span></span><br><span class="line">        dictt = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(t)):</span><br><span class="line">            dictt[t[i]].append(i)</span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            idx = bisect.bisect_left(dictt[c], start)</span><br><span class="line">            print(idx)</span><br><span class="line">            <span class="keyword">if</span> len(dictt[c]) == <span class="number">0</span> <span class="keyword">or</span> idx &gt;= len(dictt[c]):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            start = dictt[c][idx] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined" target="_blank" rel="noopener">Pinecone</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://www.pinew.top/2020/01/16/BinarySearch/">https://www.pinew.top/2020/01/16/BinarySearch/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jwu424/Blog_source@master/img/U2En1ED8DLs.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull-left"><a href="/2020/01/20/LinkedList/"><img class="prev_cover lozad" data-src="https://cdn.jsdelivr.net/gh/jwu424/Blog_source@master/img/C9IVeNsV7hY.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Previous Post</div><div class="prev_info"><span>LinkedList</span></div></a></div><div class="next-post pull-right"><a href="/2020/01/06/DFS/"><img class="next_cover lozad" data-src="https://cdn.jsdelivr.net/gh/jwu424/Blog_source@master/img/KjqN-SVI7CI.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Next Post</div><div class="next_info"><span>DFS</span></div></a></div></nav></div></div><footer><div id="footer"><div class="copyright">&copy;2019 - 2020 By Pinecone</div><div class="framework-info"><span>Driven </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">Welcome!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><i class="nightshift fa fa-moon-o" id="nightshift" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="Scroll to comment"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script src="/js/nightshift.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script>const observer = lozad(); // lazy loads elements with default selector as '.lozad'
observer.observe();
</script></body></html>