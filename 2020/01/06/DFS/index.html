<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>DFS | Pinecone</title><meta name="description" content="DFS"><meta name="keywords" content=""><meta name="author" content="Pinecone"><meta name="copyright" content="Pinecone"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="https://www.pinew.top/2020/01/06/DFS/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="DFS"><meta name="twitter:description" content="DFS"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jwu424/Blog_source@master/img/7-oM8eFUkFQ.jpg"><meta property="og:type" content="article"><meta property="og:title" content="DFS"><meta property="og:url" content="https://www.pinew.top/2020/01/06/DFS/"><meta property="og:site_name" content="Pinecone"><meta property="og:description" content="DFS"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/jwu424/Blog_source@master/img/7-oM8eFUkFQ.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="prev" title="BinarySearch" href="https://www.pinew.top/2020/01/16/BinarySearch/"><link rel="next" title="BFS" href="https://www.pinew.top/2019/12/28/BFS/"><meta name="google-site-verification" content="google078980f9392d4c28.html"><meta name="baidu-site-verification" content="baidu_verify_4E5F1x6oOR.html"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight_copy: 'true',
  highlight_lang: 'true',
  highlight_shrink: 'true',
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    title: 'Bookmark',
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  copyright: undefined,
  copy_copyright_js: false
  
}</script></head><body><canvas class="fireworks"></canvas><div id="header"> <div id="page-header"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">Pinecone</a></span><i class="fa fa-bars fa-fw toggle-menu pull-right close" aria-hidden="true"></i><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw far fa-image"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/books/"><i class="fa-fw fa fa-book"></i><span> Books</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movies</span></a></li><li><a class="site-page" href="/games/"><i class="fa-fw fa fa-gamepad"></i><span> Games</span></a></li></ul></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lozad avatar_img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">17</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">4</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">Categories</div><div class="length_num">4</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw far fa-image"></i><span> Gallery</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/books/"><i class="fa-fw fa fa-book"></i><span> Books</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movies</span></a></li><li><a class="site-page" href="/games/"><i class="fa-fw fa fa-gamepad"></i><span> Games</span></a></li></ul></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">Catalog</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Leetcode-98-Validate-Binary-Search-Tree"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">Leetcode 98 : Validate Binary Search Tree</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Leetcode-99-Recover-Binary-Search-Tree"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">Leetcode 99: Recover Binary Search Tree</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Leetcode-100-Same-Tree"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">Leetcode 100: Same Tree</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Leetcode-104-Maximum-Depth-of-Binary-Tree"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">Leetcode 104: Maximum Depth of Binary Tree</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Leetcode-105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">Leetcode 105: : Construct Binary Tree from Preorder and Inorder Traversal</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Leetcode-106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">Leetcode 106: Construct Binary Tree from Inorder and Postorder Traversal</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Leetcode-108"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text">Leetcode 108:</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Leetcode-109"><span class="toc_mobile_items-number">8.</span> <span class="toc_mobile_items-text">Leetcode 109:</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Leetcode-110-Balanced-Binary-Tree"><span class="toc_mobile_items-number">9.</span> <span class="toc_mobile_items-text">Leetcode 110: Balanced Binary Tree</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Leetcode-111-Minimum-Depth-of-Binary-Tree"><span class="toc_mobile_items-number">10.</span> <span class="toc_mobile_items-text">Leetcode 111: Minimum Depth of Binary Tree</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Leetcode-112-Path-Sum"><span class="toc_mobile_items-number">11.</span> <span class="toc_mobile_items-text">Leetcode 112: Path Sum</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Leetcode-113-Path-Sum-II"><span class="toc_mobile_items-number">12.</span> <span class="toc_mobile_items-text">Leetcode 113: Path Sum II</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Leetcode-114-Flatten-Binary-Tree-to-Linked-ListGiven-a-binary-tree-flatten-it-to-a-linked-list-in-place"><span class="toc_mobile_items-number">13.</span> <span class="toc_mobile_items-text">Leetcode 114: Flatten Binary Tree to Linked ListGiven a binary tree, flatten it to a linked list in-place.</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Leetcode-116-Populating-Next-Right-Pointers-in-Each-Node"><span class="toc_mobile_items-number">14.</span> <span class="toc_mobile_items-text">Leetcode 116: Populating Next Right Pointers in Each Node</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Leetcode-117-Populating-Next-Right-Pointers-in-Each-Node-II"><span class="toc_mobile_items-number">15.</span> <span class="toc_mobile_items-text">Leetcode 117: Populating Next Right Pointers in Each Node II</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Leetcode-124-Binary-Tree-Maximum-Path-Sum"><span class="toc_mobile_items-number">16.</span> <span class="toc_mobile_items-text">Leetcode 124: Binary Tree Maximum Path Sum</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Leetcode-129-Sum-Root-to-Leaf-Numbers"><span class="toc_mobile_items-number">17.</span> <span class="toc_mobile_items-text">Leetcode 129: Sum Root to Leaf Numbers</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Leetcode-257-Binary-Tree-Paths"><span class="toc_mobile_items-number">18.</span> <span class="toc_mobile_items-text">Leetcode 257: Binary Tree Paths</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Leetcode-329-Longest-Increasing-Path-in-a-Matrix"><span class="toc_mobile_items-number">19.</span> <span class="toc_mobile_items-text">Leetcode 329: Longest Increasing Path in a Matrix</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Leetcode-332-Reconstruct-Itinerary"><span class="toc_mobile_items-number">20.</span> <span class="toc_mobile_items-text">Leetcode 332: Reconstruct Itinerary</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Leetcode-337-House-Robber-III"><span class="toc_mobile_items-number">21.</span> <span class="toc_mobile_items-text">Leetcode 337: House Robber III</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Leetcode-394-Decode-String"><span class="toc_mobile_items-number">22.</span> <span class="toc_mobile_items-text">Leetcode 394: Decode String</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Leetcode-257-Binary-Tree-Paths-1"><span class="toc_mobile_items-number">23.</span> <span class="toc_mobile_items-text">Leetcode 257: Binary Tree Paths</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Leetcode-257-Binary-Tree-Paths-2"><span class="toc_mobile_items-number">24.</span> <span class="toc_mobile_items-text">Leetcode 257: Binary Tree Paths</span></a></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-98-Validate-Binary-Search-Tree"><span class="toc-number">1.</span> <span class="toc-text">Leetcode 98 : Validate Binary Search Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-99-Recover-Binary-Search-Tree"><span class="toc-number">2.</span> <span class="toc-text">Leetcode 99: Recover Binary Search Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-100-Same-Tree"><span class="toc-number">3.</span> <span class="toc-text">Leetcode 100: Same Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-104-Maximum-Depth-of-Binary-Tree"><span class="toc-number">4.</span> <span class="toc-text">Leetcode 104: Maximum Depth of Binary Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><span class="toc-number">5.</span> <span class="toc-text">Leetcode 105: : Construct Binary Tree from Preorder and Inorder Traversal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal"><span class="toc-number">6.</span> <span class="toc-text">Leetcode 106: Construct Binary Tree from Inorder and Postorder Traversal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-108"><span class="toc-number">7.</span> <span class="toc-text">Leetcode 108:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-109"><span class="toc-number">8.</span> <span class="toc-text">Leetcode 109:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-110-Balanced-Binary-Tree"><span class="toc-number">9.</span> <span class="toc-text">Leetcode 110: Balanced Binary Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-111-Minimum-Depth-of-Binary-Tree"><span class="toc-number">10.</span> <span class="toc-text">Leetcode 111: Minimum Depth of Binary Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-112-Path-Sum"><span class="toc-number">11.</span> <span class="toc-text">Leetcode 112: Path Sum</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-113-Path-Sum-II"><span class="toc-number">12.</span> <span class="toc-text">Leetcode 113: Path Sum II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-114-Flatten-Binary-Tree-to-Linked-ListGiven-a-binary-tree-flatten-it-to-a-linked-list-in-place"><span class="toc-number">13.</span> <span class="toc-text">Leetcode 114: Flatten Binary Tree to Linked ListGiven a binary tree, flatten it to a linked list in-place.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-116-Populating-Next-Right-Pointers-in-Each-Node"><span class="toc-number">14.</span> <span class="toc-text">Leetcode 116: Populating Next Right Pointers in Each Node</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-117-Populating-Next-Right-Pointers-in-Each-Node-II"><span class="toc-number">15.</span> <span class="toc-text">Leetcode 117: Populating Next Right Pointers in Each Node II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-124-Binary-Tree-Maximum-Path-Sum"><span class="toc-number">16.</span> <span class="toc-text">Leetcode 124: Binary Tree Maximum Path Sum</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-129-Sum-Root-to-Leaf-Numbers"><span class="toc-number">17.</span> <span class="toc-text">Leetcode 129: Sum Root to Leaf Numbers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-257-Binary-Tree-Paths"><span class="toc-number">18.</span> <span class="toc-text">Leetcode 257: Binary Tree Paths</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-329-Longest-Increasing-Path-in-a-Matrix"><span class="toc-number">19.</span> <span class="toc-text">Leetcode 329: Longest Increasing Path in a Matrix</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-332-Reconstruct-Itinerary"><span class="toc-number">20.</span> <span class="toc-text">Leetcode 332: Reconstruct Itinerary</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-337-House-Robber-III"><span class="toc-number">21.</span> <span class="toc-text">Leetcode 337: House Robber III</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-394-Decode-String"><span class="toc-number">22.</span> <span class="toc-text">Leetcode 394: Decode String</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-257-Binary-Tree-Paths-1"><span class="toc-number">23.</span> <span class="toc-text">Leetcode 257: Binary Tree Paths</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-257-Binary-Tree-Paths-2"><span class="toc-number">24.</span> <span class="toc-text">Leetcode 257: Binary Tree Paths</span></a></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/jwu424/Blog_source@master/img/7-oM8eFUkFQ.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">DFS</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> Created 2020-01-06<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> Updated 2020-01-16</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Leetcode/">Leetcode</a></span><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">4.3k</span><span class="post-meta__separator">|</span><span>Reading time: 27 min</span><span class="post-meta__separator">|</span><span>Post View: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h3 id="Leetcode-98-Validate-Binary-Search-Tree"><a href="#Leetcode-98-Validate-Binary-Search-Tree" class="headerlink" title="Leetcode 98 : Validate Binary Search Tree"></a>Leetcode 98 : Validate Binary Search Tree</h3><p>Given a binary tree, determine if it is a valid binary search tree (BST).</p>
<p>Assume a BST is defined as follows:</p>
<ul>
<li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node’s key.</li>
<li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node’s key.</li>
<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>
<p><strong>Answer:</strong></p>
<p>We also need to make sure that given a node A, if left subtree exists, all values of nodes in left subtree should larger than the value of A. If right subtree exists, all values of nodes in right subtree should smaller than the value of A.</p>
<p>Recursive:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        min_val, max_val = float(<span class="string">'-inf'</span>), float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">return</span> self.helper(root, min_val, max_val)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, node, min_val, max_val)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        val = node.val</span><br><span class="line">        <span class="keyword">if</span> val &lt;= min_val <span class="keyword">or</span> val &gt;= max_val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.helper(node.right, val, max_val):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.helper(node.left, min_val, val):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>Iterative:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        stack = [(root, float(<span class="string">'-inf'</span>), float(<span class="string">'inf'</span>))]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node, min_val, max_val = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            val = node.val</span><br><span class="line">            <span class="keyword">if</span> val &lt;= min_val <span class="keyword">or</span> val &gt;= max_val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            stack.append((node.left, min_val, val))</span><br><span class="line">            stack.append((node.right, val, max_val))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>Inorder traversal:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">		stack, inorder = [], float(<span class="string">'-inf'</span>)</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> root:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">        	root = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> root.val &lt;= inorder:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            inorder = root.val</span><br><span class="line">            root = root.right</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-99-Recover-Binary-Search-Tree"><a href="#Leetcode-99-Recover-Binary-Search-Tree" class="headerlink" title="Leetcode 99: Recover Binary Search Tree"></a>Leetcode 99: Recover Binary Search Tree</h3><p>Two elements of a binary search tree (BST) are swapped by mistake.</p>
<p>Recover the tree without changing its structure.</p>
<p><strong>Answer:</strong></p>
<p>Simple idea is to use inorder traversal. Then we can sort the output and get which two elements are swapped by mistake. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time: O(NlogN)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorder</span><span class="params">(self, root, s)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: </span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">if</span> root.left: </span><br><span class="line">            self.inorder(root.left, s)</span><br><span class="line">        s.append(root.val)</span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            self.inorder(root.right, s)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recover</span><span class="params">(self, root, a, b)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            self.recover(root.left, a, b)</span><br><span class="line">        <span class="keyword">if</span> root.val == a:</span><br><span class="line">            root.val = b</span><br><span class="line">        <span class="keyword">elif</span> root.val == b:</span><br><span class="line">            root.val = a</span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            self.recover(root.right, a, b)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recoverTree</span><span class="params">(self, root: TreeNode)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        s = []</span><br><span class="line">        err = []</span><br><span class="line">        self.inorder(root, s)</span><br><span class="line">        a = s[:]</span><br><span class="line">        s.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] != a[i]:</span><br><span class="line">                err.append(s[i])</span><br><span class="line">                err.append(a[i])</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        self.recover(root, err[<span class="number">0</span>], err[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>We use inorder traversal, but record the two swapped elements. Finally we switch them.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time: O(N), Space: O(N)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recoverTree</span><span class="params">(self, root: TreeNode)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        stack = []</span><br><span class="line">        trav = root</span><br><span class="line">        prev = <span class="literal">None</span></span><br><span class="line">        <span class="comment"># Used to record two swapped elements</span></span><br><span class="line">        first, second = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> trav:</span><br><span class="line">            <span class="keyword">if</span> trav:</span><br><span class="line">                stack.append(trav)</span><br><span class="line">                trav = trav.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = stack.pop()</span><br><span class="line">                <span class="comment"># If the increase pattern is not satisfied, and we still not have</span></span><br><span class="line">                <span class="comment"># the first one, we record it and also we record the second with cur</span></span><br><span class="line">                <span class="comment"># in case the swapped elements are next to each other and we don't</span></span><br><span class="line">                <span class="comment"># have second time of breaking increase pattern. </span></span><br><span class="line">                <span class="keyword">if</span> prev <span class="keyword">and</span> prev.val &gt; cur.val:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> first:</span><br><span class="line">                        first = prev</span><br><span class="line">                    second = cur</span><br><span class="line">                prev = cur</span><br><span class="line">                trav = cur.right</span><br><span class="line">        first.val, second.val = first.val, second.val</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-100-Same-Tree"><a href="#Leetcode-100-Same-Tree" class="headerlink" title="Leetcode 100: Same Tree"></a>Leetcode 100: Same Tree</h3><p>Given two binary trees, write a function to check if they are the same or not.</p>
<p>Two binary trees are considered the same if they are structurally identical and the nodes have the same value.</p>
<p><strong>Answer:</strong></p>
<p>Traversal the tree and check if the nodes are same or not.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time: O(N)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span><span class="params">(self, p: TreeNode, q: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> p <span class="keyword">and</span> q <span class="keyword">and</span> p.val == q.val:</span><br><span class="line">            a1 = self.isSameTree(p.left, q.left)</span><br><span class="line">            a2 = self.isSameTree(p.right, q.right)</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> p <span class="keyword">and</span> <span class="keyword">not</span> q:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> a1 <span class="keyword">and</span> a2</span><br></pre></td></tr></table></figure>
<p>Shorter way:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span><span class="params">(self, p: TreeNode, q: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> p <span class="keyword">and</span> q:</span><br><span class="line">            <span class="keyword">return</span> p.val == q.val <span class="keyword">and</span> self.isSameTree(p.left, q.left) <span class="keyword">and</span> self.isSameTree(p.right, q.right)</span><br><span class="line">        <span class="keyword">return</span> p <span class="keyword">is</span> q</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-104-Maximum-Depth-of-Binary-Tree"><a href="#Leetcode-104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="Leetcode 104: Maximum Depth of Binary Tree"></a>Leetcode 104: Maximum Depth of Binary Tree</h3><p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<p><strong>Answer:</strong></p>
<p>DFS + recursive:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.dfs(root, <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, curNode, level)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> curNode:</span><br><span class="line">            <span class="keyword">return</span> level</span><br><span class="line">        <span class="keyword">return</span> max(self.dfs(curNode.left, level+<span class="number">1</span>), self.dfs(curNode.right, level+<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>BFS:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        queue = deque()</span><br><span class="line">        queue.append((root, <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            cur, val = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur.left <span class="keyword">and</span> <span class="keyword">not</span> cur.right <span class="keyword">and</span> <span class="keyword">not</span> queue:</span><br><span class="line">                <span class="keyword">return</span> val</span><br><span class="line">            <span class="keyword">if</span> cur.left:</span><br><span class="line">                queue.append((cur.left, val+<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">if</span> cur.right:</span><br><span class="line">                queue.append((cur.right, val+<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><a href="#Leetcode-105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal" class="headerlink" title="Leetcode 105: : Construct Binary Tree from Preorder and Inorder Traversal"></a>Leetcode 105: : Construct Binary Tree from Preorder and Inorder Traversal</h3><p>Given preorder and inorder traversal of a tree, construct the binary tree.</p>
<p><strong>Note:</strong><br>You may assume that duplicates do not exist in the tree.</p>
<p><strong>Answer:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, preorder: List[int], inorder: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">        idx = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, val <span class="keyword">in</span> enumerate(inorder):</span><br><span class="line">            idx[val] = i</span><br><span class="line">        stack = []</span><br><span class="line">        head = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> val <span class="keyword">in</span> preorder:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">                head = TreeNode(val)</span><br><span class="line">                stack.append(head)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node = TreeNode(val)</span><br><span class="line">                <span class="keyword">if</span> idx[val] &lt; idx[stack[<span class="number">-1</span>].val]:</span><br><span class="line">                    stack[<span class="number">-1</span>].left = node</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">while</span> stack <span class="keyword">and</span> idx[stack[<span class="number">-1</span>].val] &lt; idx[val]:</span><br><span class="line">                        temp = stack.pop()</span><br><span class="line">                    temp.right = node</span><br><span class="line">                stack.append(node)</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal"><a href="#Leetcode-106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal" class="headerlink" title="Leetcode 106: Construct Binary Tree from Inorder and Postorder Traversal"></a>Leetcode 106: Construct Binary Tree from Inorder and Postorder Traversal</h3><p>Given inorder and postorder traversal of a tree, construct the binary tree.</p>
<p><strong>Note:</strong><br>You may assume that duplicates do not exist in the tree.</p>
<p><strong>Answer:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, inorder: List[int], postorder: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">        idx = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, val <span class="keyword">in</span> enumerate(inorder):</span><br><span class="line">            idx[val] = i</span><br><span class="line">        stack = []</span><br><span class="line">        head = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(postorder)<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            val = postorder[i]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">                head = TreeNode(val)</span><br><span class="line">                stack.append(head)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node = TreeNode(val)</span><br><span class="line">                <span class="keyword">if</span> idx[val] &gt; idx[stack[<span class="number">-1</span>].val]:</span><br><span class="line">                    stack[<span class="number">-1</span>].right = node</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">while</span> stack <span class="keyword">and</span> idx[stack[<span class="number">-1</span>].val] &gt; idx[val]:</span><br><span class="line">                        temp = stack.pop()</span><br><span class="line">                    temp.left = node</span><br><span class="line">                stack.append(node)</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-108"><a href="#Leetcode-108" class="headerlink" title="Leetcode 108:"></a>Leetcode 108:</h3><p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p>
<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of <em>every</em> node never differ by more than 1.</p>
<p><strong>Answer:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time: O(N)</span></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedArrayToBST</span><span class="params">(self, nums: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">return</span> self.recover(nums, len(nums))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recover</span><span class="params">(self, nums, n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            root = TreeNode(nums[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">            root = TreeNode(nums[<span class="number">0</span>])</span><br><span class="line">            right = TreeNode(nums[<span class="number">1</span>])</span><br><span class="line">            root.right = right</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        mid = n // <span class="number">2</span></span><br><span class="line">        root = TreeNode(nums[mid])</span><br><span class="line">        left = self.recover(nums[:mid], mid)</span><br><span class="line">        right = self.recover(nums[mid+<span class="number">1</span>:], n - mid - <span class="number">1</span>)</span><br><span class="line">        root.left = left</span><br><span class="line">        root.right = right</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time: O(N)</span></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedArrayToBST</span><span class="params">(self, nums: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">return</span> self.helper(nums, <span class="number">0</span>, len(nums)<span class="number">-1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, nums, left, right)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> left &gt; right:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        root = TreeNode(nums[mid])</span><br><span class="line">        root.left = self.helper(nums, left, mid - <span class="number">1</span>)</span><br><span class="line">        root.right = self.helper(nums, mid + <span class="number">1</span>, right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-109"><a href="#Leetcode-109" class="headerlink" title="Leetcode 109:"></a>Leetcode 109:</h3><p>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.</p>
<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of <em>every</em> node never differ by more than 1.</p>
<p><strong>Answer:</strong></p>
<p>We can split the list half by half and construct the tree. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time: O(NlogN), Space: O(1)</span></span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedListToBST</span><span class="params">(self, head: ListNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        trav = head</span><br><span class="line">        <span class="keyword">while</span> trav:</span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">            trav = trav.next</span><br><span class="line">        <span class="keyword">return</span> self.recover(head, length)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recover</span><span class="params">(self, head, n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            root = TreeNode(head.val)</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">            root = TreeNode(head.val)</span><br><span class="line">            right = TreeNode(head.next.val)</span><br><span class="line">            root.right = right</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        mid = n // <span class="number">2</span></span><br><span class="line">        trav = head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(mid):</span><br><span class="line">            trav = trav.next</span><br><span class="line">        root = TreeNode(trav.val)</span><br><span class="line">        left = self.recover(head, mid)</span><br><span class="line">        right = self.recover(trav.next, n - mid - <span class="number">1</span>)</span><br><span class="line">        root.left = left</span><br><span class="line">        root.right = right</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-110-Balanced-Binary-Tree"><a href="#Leetcode-110-Balanced-Binary-Tree" class="headerlink" title="Leetcode 110: Balanced Binary Tree"></a>Leetcode 110: Balanced Binary Tree</h3><p>Given a binary tree, determine if it is height-balanced.</p>
<p>For this problem, a height-balanced binary tree is defined as: a binary tree in which the left and right subtrees of <em>every</em> node differ in height by no more than 1.</p>
<p><strong>Answer:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        l = self.height(root.left)</span><br><span class="line">        r = self.height(root.right)</span><br><span class="line">        <span class="keyword">if</span> abs(l - r) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> self.isBalanced(root.left) <span class="keyword">and</span> self.isBalanced(root.right)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">height</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + max(self.height(root.left), self.height(root.right))</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-111-Minimum-Depth-of-Binary-Tree"><a href="#Leetcode-111-Minimum-Depth-of-Binary-Tree" class="headerlink" title="Leetcode 111: Minimum Depth of Binary Tree"></a>Leetcode 111: Minimum Depth of Binary Tree</h3><p>Given a binary tree, find its minimum depth.</p>
<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>
<p><strong>Note:</strong> A leaf is a node with no children.</p>
<p><strong>Answer:</strong></p>
<p>BFS:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        queue = deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            levelsize = len(queue)</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(levelsize):</span><br><span class="line">                curnode = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> curnode.left <span class="keyword">and</span> <span class="keyword">not</span> curnode.right:</span><br><span class="line">                    <span class="keyword">return</span> res</span><br><span class="line">                <span class="keyword">if</span> curnode.left:</span><br><span class="line">                    queue.append(curnode.left)</span><br><span class="line">                <span class="keyword">if</span> curnode.right:</span><br><span class="line">                    queue.append(curnode.right)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>DFS</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="literal">None</span> <span class="keyword">in</span> [root.left, root.right]:</span><br><span class="line">            <span class="keyword">return</span> max(self.minDepth(root.left), self.minDepth(root.right)) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> min(self.minDepth(root.left), self.minDepth(root.right)) + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-112-Path-Sum"><a href="#Leetcode-112-Path-Sum" class="headerlink" title="Leetcode 112: Path Sum"></a>Leetcode 112: Path Sum</h3><p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</p>
<p><strong>Note:</strong> A leaf is a node with no children.</p>
<p><strong>Answer:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time: O(N)</span></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span><span class="params">(self, root: TreeNode, sum: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> root.val == sum <span class="keyword">and</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> self.hasPathSum(root.left, sum - root.val) <span class="keyword">or</span> self.hasPathSum(root.right, sum - root.val)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span><span class="params">(self, root: TreeNode, sum: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        queue = deque()</span><br><span class="line">        queue.append((root, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            cur, total = queue.popleft()</span><br><span class="line">            total += cur.val</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur.left <span class="keyword">and</span> <span class="keyword">not</span> cur.right:</span><br><span class="line">                <span class="keyword">if</span> total == sum:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> cur.left:</span><br><span class="line">                queue.append((cur.left, total))</span><br><span class="line">            <span class="keyword">if</span> cur.right:</span><br><span class="line">                queue.append((cur.right, total))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-113-Path-Sum-II"><a href="#Leetcode-113-Path-Sum-II" class="headerlink" title="Leetcode 113: Path Sum II"></a>Leetcode 113: Path Sum II</h3><p>Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.</p>
<p><strong>Note:</strong> A leaf is a node with no children.</p>
<p><strong>Answer:</strong></p>
<p>Same idea as before.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root: TreeNode, sum: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        allPaths = []</span><br><span class="line">        self.find_paths_recursive(root, sum, [], allPaths)</span><br><span class="line">        <span class="keyword">return</span> allPaths</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_paths_recursive</span><span class="params">(self, curNode, sum, curPath, allPaths)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> curNode:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">if</span> curNode.val == sum <span class="keyword">and</span> <span class="keyword">not</span> curNode.left <span class="keyword">and</span> <span class="keyword">not</span> curNode.right:</span><br><span class="line">            allPaths.append(curPath+[curNode.val])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.find_paths_recursive(curNode.left, sum-curNode.val, curPath+[curNode.val], allPaths)</span><br><span class="line">            self.find_paths_recursive(curNode.right, sum-curNode.val, curPath+[curNode.val], allPaths)</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-114-Flatten-Binary-Tree-to-Linked-ListGiven-a-binary-tree-flatten-it-to-a-linked-list-in-place"><a href="#Leetcode-114-Flatten-Binary-Tree-to-Linked-ListGiven-a-binary-tree-flatten-it-to-a-linked-list-in-place" class="headerlink" title="Leetcode 114: Flatten Binary Tree to Linked ListGiven a binary tree, flatten it to a linked list in-place."></a>Leetcode 114: Flatten Binary Tree to Linked ListGiven a binary tree, flatten it to a linked list in-place.</h3><p>For example, given the following tree:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   5</span><br><span class="line"> / \   \</span><br><span class="line">3   4   6</span><br></pre></td></tr></table></figure>
<p>The flattened tree should look like:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line">   \</span><br><span class="line">    3</span><br><span class="line">     \</span><br><span class="line">      4</span><br><span class="line">       \</span><br><span class="line">        5</span><br><span class="line">         \</span><br><span class="line">          6</span><br></pre></td></tr></table></figure>
<p><strong>Answer:</strong></p>
<p>Ideally, first flatten left and right branches. We can use recursive DFS.</p>
<p>Then, replace curNode.right with the flattened left and add the flattened right at the end of the flattened left. Make sure curNode.left = None. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(self, root: TreeNode)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.helper(root)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        l = self.helper(root.left)</span><br><span class="line">        r = self.helper(root.right)</span><br><span class="line">        <span class="keyword">if</span> l:</span><br><span class="line">            root.right = l</span><br><span class="line">            <span class="keyword">while</span> l <span class="keyword">and</span> l.right:</span><br><span class="line">                l = l.right</span><br><span class="line">            l.right = r</span><br><span class="line">            root.left = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-116-Populating-Next-Right-Pointers-in-Each-Node"><a href="#Leetcode-116-Populating-Next-Right-Pointers-in-Each-Node" class="headerlink" title="Leetcode 116: Populating Next Right Pointers in Each Node"></a>Leetcode 116: Populating Next Right Pointers in Each Node</h3><p>Given a <strong>perfect binary tree</strong>, connect each node with its level order successor. The last node of each level should point to a <code>null</code> node.</p>
<p><strong>Answer:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time: O(N)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">and</span> root.left <span class="keyword">and</span> root.right:</span><br><span class="line">            root.left.next = root.right</span><br><span class="line">            <span class="keyword">if</span> root.next:</span><br><span class="line">                root.right.next = root.next.left</span><br><span class="line">            self.connect(root.left)</span><br><span class="line">            self.connect(root.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p>BFS</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time: O(N), Space: O(N)</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left = left</span></span><br><span class="line"><span class="string">        self.right = right</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        queue = deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            preNode = <span class="literal">None</span></span><br><span class="line">            curLevel = len(queue)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(curLevel):</span><br><span class="line">                curNode = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> curNode.left:</span><br><span class="line">                    queue.append(curNode.left)</span><br><span class="line">                <span class="keyword">if</span> curNode.right:</span><br><span class="line">                    queue.append(curNode.right)</span><br><span class="line">                <span class="keyword">if</span> preNode:</span><br><span class="line">                    preNode.next = curNode</span><br><span class="line">                preNode = curNode</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p>DFS:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        stack = [root]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            curNode = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> curNode.left <span class="keyword">and</span> curNode.right:</span><br><span class="line">                curNode.left.next = curNode.right</span><br><span class="line">                <span class="keyword">if</span> curNode.next:</span><br><span class="line">                    curNode.right.next = curNode.next.left</span><br><span class="line">                stack.append(curNode.right)</span><br><span class="line">                stack.append(curNode.left)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-117-Populating-Next-Right-Pointers-in-Each-Node-II"><a href="#Leetcode-117-Populating-Next-Right-Pointers-in-Each-Node-II" class="headerlink" title="Leetcode 117: Populating Next Right Pointers in Each Node II"></a>Leetcode 117: Populating Next Right Pointers in Each Node II</h3><p>Given a <strong>binary tree</strong>, connect each node with its level order successor. The last node of each level should point to a <code>null</code> node.</p>
<p><strong>Answer:</strong></p>
<p>This time, the tree is not perfect. But the above BFS still works.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time: O(N), Space: O(N)</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left = left</span></span><br><span class="line"><span class="string">        self.right = right</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        queue = deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            preNode = <span class="literal">None</span></span><br><span class="line">            curLevel = len(queue)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(curLevel):</span><br><span class="line">                curNode = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> curNode.left:</span><br><span class="line">                    queue.append(curNode.left)</span><br><span class="line">                <span class="keyword">if</span> curNode.right:</span><br><span class="line">                    queue.append(curNode.right)</span><br><span class="line">                <span class="keyword">if</span> preNode:</span><br><span class="line">                    preNode.next = curNode</span><br><span class="line">                preNode = curNode</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p>Another way is that we can treat it as LinkedList, since we have next.</p>
<p>We use level to record the first element of each level of tree. We loop queue and use curr to connect. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time: O(N), Space: O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        queue, level, curr = root, <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="keyword">if</span> queue.left:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> level:</span><br><span class="line">                    level = curr = queue.left</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    curr.next = queue.left</span><br><span class="line">                    curr = curr.next</span><br><span class="line">            <span class="keyword">if</span> queue.right:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> level:</span><br><span class="line">                    level = curr = queue.right</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    curr.next = queue.right</span><br><span class="line">                    curr = curr.next</span><br><span class="line">            queue = queue.next</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> queue <span class="keyword">and</span> level:</span><br><span class="line">                queue, level, curr = level, <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-124-Binary-Tree-Maximum-Path-Sum"><a href="#Leetcode-124-Binary-Tree-Maximum-Path-Sum" class="headerlink" title="Leetcode 124: Binary Tree Maximum Path Sum"></a>Leetcode 124: Binary Tree Maximum Path Sum</h3><p>Given a <strong>non-empty</strong> binary tree, find the maximum path sum.</p>
<p>For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain <strong>at least one node</strong> and does not need to go through the root.</p>
<p><strong>Answer:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time: O(N)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPathSum</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        self.globalMax = float(<span class="string">'-inf'</span>)</span><br><span class="line">        self.find_max_recursive(root)</span><br><span class="line">        <span class="keyword">return</span> self.globalMax</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_max_recursive</span><span class="params">(self, curNode)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> curNode:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># Use max to ignore negative val</span></span><br><span class="line">        maxPathLeft = max(self.find_max_recursive(curNode.left), <span class="number">0</span>)</span><br><span class="line">        maxPathRight = max(self.find_max_recursive(curNode.right), <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        localMax = maxPathLeft + maxPathRight + curNode.val</span><br><span class="line">        self.globalMax = max(localMax, self.globalMax)</span><br><span class="line">        <span class="comment"># Return the max path of current subtree</span></span><br><span class="line">        <span class="keyword">return</span> max(maxPathLeft, maxPathRight) + curNode.val</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-129-Sum-Root-to-Leaf-Numbers"><a href="#Leetcode-129-Sum-Root-to-Leaf-Numbers" class="headerlink" title="Leetcode 129: Sum Root to Leaf Numbers"></a>Leetcode 129: Sum Root to Leaf Numbers</h3><p>Given a binary tree containing digits from <code>0-9</code> only, each root-to-leaf path could represent a number.</p>
<p>An example is the root-to-leaf path <code>1-&gt;2-&gt;3</code> which represents the number <code>123</code>.</p>
<p>Find the total sum of all root-to-leaf numbers.</p>
<p><strong>Answer:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time: O(N)</span></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumNumbers</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line">        self.findPath(root, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPath</span><span class="params">(self, curNode, temp)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> curNode:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        temp = temp * <span class="number">10</span> + curNode.val</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> curNode.left <span class="keyword">and</span> <span class="keyword">not</span> curNode.right:</span><br><span class="line">            self.res += temp</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        self.findPath(curNode.left, temp)</span><br><span class="line">        self.findPath(curNode.right, temp)</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-257-Binary-Tree-Paths"><a href="#Leetcode-257-Binary-Tree-Paths" class="headerlink" title="Leetcode 257: Binary Tree Paths"></a>Leetcode 257: Binary Tree Paths</h3><p>Given a binary tree, return all root-to-leaf paths.</p>
<p><strong>Note:</strong> A leaf is a node with no children.</p>
<p><strong>Answer:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binaryTreePaths</span><span class="params">(self, root: TreeNode)</span> -&gt; List[str]:</span></span><br><span class="line">        self.res = []</span><br><span class="line">        self.find_all(root, <span class="string">''</span>)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_all</span><span class="params">(self, curNode, temp)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> curNode:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> curNode.left <span class="keyword">and</span> <span class="keyword">not</span> curNode.right:</span><br><span class="line">            self.res.append(temp + str(curNode.val))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.find_all(curNode.left, temp+str(curNode.val)+<span class="string">'-&gt;'</span>)</span><br><span class="line">            self.find_all(curNode.right, temp+str(curNode.val)+<span class="string">'-&gt;'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-329-Longest-Increasing-Path-in-a-Matrix"><a href="#Leetcode-329-Longest-Increasing-Path-in-a-Matrix" class="headerlink" title="Leetcode 329: Longest Increasing Path in a Matrix"></a>Leetcode 329: Longest Increasing Path in a Matrix</h3><p>Given an integer matrix, find the length of the longest increasing path.</p>
<p>From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).</p>
<p><strong>Answer:</strong></p>
<p>DFS + memoization</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time: O(MN), Space(MN)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestIncreasingPath</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; int:</span>        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> <span class="keyword">not</span> matrix[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        n = len(matrix)</span><br><span class="line">        m = len(matrix[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">0</span>] * m <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                res = max(res, self.dfs(matrix, dp, i, j, n, m))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, matrix, dp, i, j, n, m)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> dp[i][j] != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> dp[i][j]</span><br><span class="line">        dirs = &#123;(i<span class="number">-1</span>,j), (i+<span class="number">1</span>,j), (i,j<span class="number">-1</span>), (i,j+<span class="number">1</span>)&#125;</span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> dirs:</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= x &lt; n <span class="keyword">and</span> <span class="number">0</span> &lt;= y &lt; m:</span><br><span class="line">                <span class="keyword">if</span> matrix[x][y] &gt; matrix[i][j]:</span><br><span class="line">                    dp[i][j] = max(dp[i][j], self.dfs(matrix, dp, x, y, n, m))</span><br><span class="line">        dp[i][j] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp[i][j]</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-332-Reconstruct-Itinerary"><a href="#Leetcode-332-Reconstruct-Itinerary" class="headerlink" title="Leetcode 332: Reconstruct Itinerary"></a>Leetcode 332: Reconstruct Itinerary</h3><p>Given a list of airline tickets represented by pairs of departure and arrival airports <code>[from, to]</code>, reconstruct the itinerary in order. All of the tickets belong to a man who departs from <code>JFK</code>. Thus, the itinerary must begin with <code>JFK</code>.</p>
<p><strong>Note:</strong></p>
<ol>
<li>If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary <code>[&quot;JFK&quot;, &quot;LGA&quot;]</code> has a smaller lexical order than <code>[&quot;JFK&quot;, &quot;LGB&quot;]</code>.</li>
<li>All airports are represented by three capital letters (IATA code).</li>
<li>You may assume all tickets form at least one valid itinerary.</li>
</ol>
<p><strong>Answer:</strong></p>
<ol>
<li>For each departure, we construct a deque of <strong>sorted</strong> destinations and store it in HashMap.</li>
<li>Starting from JFK, we try to build a path. The maximum length of path = len(tickets) + 1. Once we get this length, we stop DFS. </li>
<li>Backtracking is necessary. </li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findItinerary</span><span class="params">(self, tickets: List[List[str]])</span> -&gt; List[str]:</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root, graph, path, maxLen)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(path) == maxLen:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(graph.get(root, []))):</span><br><span class="line">                nextStation = graph[root].popleft()</span><br><span class="line">                path.append(nextStation)</span><br><span class="line">                <span class="keyword">if</span> dfs(nextStation, graph, path, maxLen):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                path.pop()</span><br><span class="line">                graph[root].append(nextStation)</span><br><span class="line">        </span><br><span class="line">            </span><br><span class="line">        graph = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> ticket <span class="keyword">in</span> tickets:</span><br><span class="line">            graph[ticket[<span class="number">0</span>]] = graph.get(ticket[<span class="number">0</span>], []) + [ticket[<span class="number">1</span>]]</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> graph:</span><br><span class="line">            graph[key] = deque(sorted(graph[key]))</span><br><span class="line">        path = [<span class="string">'JFK'</span>]</span><br><span class="line">        dfs(<span class="string">'JFK'</span>, graph, path, len(tickets) + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> path</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-337-House-Robber-III"><a href="#Leetcode-337-House-Robber-III" class="headerlink" title="Leetcode 337: House Robber III"></a>Leetcode 337: House Robber III</h3><p>The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the “root.” Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that “all houses in this place forms a binary tree”. It will automatically contact the police if two directly-linked houses were broken into on the same night.</p>
<p>Determine the maximum amount of money the thief can rob tonight without alerting the police.</p>
<p><strong>Answer:</strong></p>
<p>Using recursive to solve the problem. </p>
<p>If we want to find the maximum rob money for root, we definitely want to know the maximum money for root.left and root.right. </p>
<p>If we rob root, we can’t rob root.left and root.right, but we can do it for root.left.left, root.left.right, root.right.left and root.right.right.</p>
<p>If we don’t rob root, we can do for root.left and root.right.</p>
<p>What we need to do is to choose which scenario.</p>
<p>Also, we store the result for each node to avoid duplicate calculations. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.dfs(root, &#123;&#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, root, cache)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> root <span class="keyword">in</span> cache:</span><br><span class="line">            <span class="keyword">return</span> cache[root]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            temp = root.val</span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                temp += self.dfs(root.left.left, cache) + self.dfs(root.left.right, cache)</span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                temp += self.dfs(root.right.left, cache) + self.dfs(root.right.right, cache)</span><br><span class="line">            temp2 = self.dfs(root.left, cache) + self.dfs(root.right, cache)</span><br><span class="line">            cache[root] = max(temp, temp2)</span><br><span class="line">            <span class="keyword">return</span> cache[root]</span><br></pre></td></tr></table></figure>
<p>Avoid duplicate situation.</p>
<p>For each node, we return two values: include node and exclude node.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> max(self.dfs(root))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            include1, exclude1 = self.dfs(root.left)</span><br><span class="line">            include2, exclude2 = self.dfs(root.right)</span><br><span class="line">            include = root.val + exclude1 + exclude2</span><br><span class="line">            exclude = max(include1, exclude1) + max(include2, exclude2)</span><br><span class="line">            <span class="keyword">return</span> include, exclude</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-394-Decode-String"><a href="#Leetcode-394-Decode-String" class="headerlink" title="Leetcode 394: Decode String"></a>Leetcode 394: Decode String</h3><p>Given an encoded string, return its decoded string.</p>
<p>The encoding rule is: <code>k[encoded_string]</code>, where the <em>encoded_string</em> inside the square brackets is being repeated exactly <em>k</em> times. Note that <em>k</em> is guaranteed to be a positive integer.</p>
<p>You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.</p>
<p>Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, <em>k</em>. For example, there won’t be input like <code>3a</code> or <code>2[4]</code>.</p>
<p><strong>Examples:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;3[a]2[bc]&quot;, return &quot;aaabcbc&quot;.</span><br><span class="line">s = &quot;3[a2[c]]&quot;, return &quot;accaccacc&quot;.</span><br><span class="line">s = &quot;2[abc]3[cd]ef&quot;, return &quot;abcabccdcdcdef&quot;.</span><br></pre></td></tr></table></figure>
<p><strong>Answer:</strong></p>
<p>We can use stack to solve problem.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decodeString</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> chr <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> chr != <span class="string">']'</span>:</span><br><span class="line">                stack.append(chr)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                temp_s = <span class="string">''</span></span><br><span class="line">                <span class="keyword">while</span> stack:</span><br><span class="line">                    x = stack.pop()</span><br><span class="line">                    <span class="keyword">if</span> x != <span class="string">'['</span>:</span><br><span class="line">                        <span class="comment"># the order of x and temp_s is important. </span></span><br><span class="line">                        temp_s = x + temp_s</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        n = <span class="string">''</span></span><br><span class="line">                        <span class="keyword">while</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>].isdigit():</span><br><span class="line">                            <span class="comment"># the number may be larger than 9. </span></span><br><span class="line">                            n = stack.pop() + n</span><br><span class="line">                        stack.append(temp_s * int(n))</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(stack)</span><br></pre></td></tr></table></figure>
<p>DFS</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decodeString</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">return</span> self.dfs(s, <span class="number">0</span>)[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, s, i)</span>:</span></span><br><span class="line">        res, num, length = <span class="string">''</span>, <span class="number">0</span>, len(s)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> i &lt; length:</span><br><span class="line">            chr = s[i]</span><br><span class="line">            <span class="keyword">if</span> chr.isdigit():</span><br><span class="line">                num = num * <span class="number">10</span> + int(chr)</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> chr == <span class="string">'['</span>:</span><br><span class="line">                temp, i = self.dfs(s, i+<span class="number">1</span>)</span><br><span class="line">                res += num * temp</span><br><span class="line">                num = <span class="number">0</span></span><br><span class="line">            <span class="keyword">elif</span> chr == <span class="string">']'</span>:</span><br><span class="line">                <span class="keyword">return</span> res, i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += chr</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res, i</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-257-Binary-Tree-Paths-1"><a href="#Leetcode-257-Binary-Tree-Paths-1" class="headerlink" title="Leetcode 257: Binary Tree Paths"></a>Leetcode 257: Binary Tree Paths</h3><h3 id="Leetcode-257-Binary-Tree-Paths-2"><a href="#Leetcode-257-Binary-Tree-Paths-2" class="headerlink" title="Leetcode 257: Binary Tree Paths"></a>Leetcode 257: Binary Tree Paths</h3></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined" target="_blank" rel="noopener">Pinecone</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://www.pinew.top/2020/01/06/DFS/">https://www.pinew.top/2020/01/06/DFS/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jwu424/Blog_source@master/img/7-oM8eFUkFQ.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull-left"><a href="/2020/01/16/BinarySearch/"><img class="prev_cover lozad" data-src="https://cdn.jsdelivr.net/gh/jwu424/Blog_source@master/img/jH1YFFPBp_I.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Previous Post</div><div class="prev_info"><span>BinarySearch</span></div></a></div><div class="next-post pull-right"><a href="/2019/12/28/BFS/"><img class="next_cover lozad" data-src="https://cdn.jsdelivr.net/gh/jwu424/Blog_source@master/img/U2En1ED8DLs.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Next Post</div><div class="next_info"><span>BFS</span></div></a></div></nav></div></div><footer><div id="footer"><div class="copyright">&copy;2019 - 2020 By Pinecone</div><div class="framework-info"><span>Driven </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">Welcome!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><i class="nightshift fa fa-moon-o" id="nightshift" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="Scroll to comment"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script src="/js/nightshift.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script>const observer = lozad(); // lazy loads elements with default selector as '.lozad'
observer.observe();
</script></body></html>